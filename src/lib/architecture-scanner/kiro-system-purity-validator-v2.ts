/**
 * Kiro System Purity Validator v2 - Production Grade
 * 
 * Bounded, abortable validation with proper timeout handling
 */

import fs from 'node:fs/promises';
import path from 'node:path';
import fg from 'fast-glob';

const DEFAULT_PATTERNS = [
  'src/**/*.{ts,tsx,js,jsx}',
  '!src/**/__tests__/**',
  '!src/**/?(*.)+(spec|test).*',
  '!**/node_modules/**',
  '!**/dist/**',
  '!**/build/**',
  '!**/.next/**',
  '!**/.vercel/**',
  '!**/coverage/**',
  '!**/playwright-report/**',
  '!**/.git/**',
  '!src/archive/**',
  '!archive/**',
  '!reports/**',
];

async function mapLimit<T, R>(
  items: T[],
  limit: number,
  fn: (item: T, i: number) => Promise<R>,
): Promise<R[]> {
  const out: R[] = new Array(items.length);
  let i = 0;
  const running = new Set<Promise<void>>();

  const launch = (idx: number) => {
    const p = (async () => { out[idx] = await fn(items[idx], idx); })()
      .finally(() => running.delete(p));
    running.add(p);
    return p;
  };

  while (i < items.length) {
    while (running.size < limit && i < items.length) launch(i++);
    if (running.size >= limit) await Promise.race(running);
  }
  await Promise.all(running);
  return out;
}

export async function findProjectFiles(options?: {
  cwd?: string;
  patterns?: string[];
  maxDepth?: number;
}) {
  const patterns = options?.patterns?.length ? options.patterns : DEFAULT_PATTERNS;
  const entries = await fg(patterns, {
    cwd: options?.cwd ?? process.cwd(),
    onlyFiles: true,
    dot: true,
    unique: true,
    dot: false,
    followSymbolicLinks: false,
    deep: options?.maxDepth ?? 12,
    absolute: true,
  });
  // filter to ts/tsx only if patterns are broad
  return entries.filter(f => /\.[tj]sx?$/.test(path.extname(f)));
}

export interface PurityScanResult {
  success: boolean;
  score: number;
  violations: Array<{
    type: string;
    severity: string;
    file: string;
    description: string;
  }>;
  components: {
    apis: { total: number; kiro: number; legacy: number; score: number };
    auth: { total: number; kiro: number; legacy: number; score: number };
    dashboard: { total: number; kiro: number; legacy: number; score: number };
    upload: { total: number; kiro: number; legacy: number; score: number };
    vc: { total: number; kiro: number; legacy: number; score: number };
    tests: { configured: boolean; score: number };
  };
  filesAnalyzed: number;
  timestamp: string;
}

export class KiroSystemPurityValidator {
  private kiroMarkers = [
    '// Generated by Kiro',
    '// Kiro-generated',
    '// @kiro-generated',
    'kiro-component',
    'kiro-service',
    'kiro-api'
  ];
  
  private supabaseMarkers = [
    'supabase',
    '@supabase',
    'createClient',
    'supabaseUrl',
    'supabaseKey'
  ];
  
  private lovableMarkers = [
    '// Lovable',
    'lovable-generated',
    '@lovable',
    'lovable.dev'
  ];

  private results = {
    apis: { total: 0, kiro: 0, legacy: 0, score: 0 },
    auth: { total: 0, kiro: 0, legacy: 0, score: 0 },
    dashboard: { total: 0, kiro: 0, legacy: 0, score: 0 },
    upload: { total: 0, kiro: 0, legacy: 0, score: 0 },
    vc: { total: 0, kiro: 0, legacy: 0, score: 0 },
    tests: { configured: false, score: 0 }
  };

  private violations: Array<{
    type: string;
    severity: string;
    file: string;
    description: string;
  }> = [];

  constructor(private opts?: { cwd?: string }) {}

  async scan(opts?: {
    patterns?: string[];
    timeoutMs?: number;
    verbose?: boolean;
    signal?: AbortSignal;
    concurrency?: number;
    maxFiles?: number;
  }): Promise<PurityScanResult> {
    const timeoutMs = opts?.timeoutMs ?? Number(process.env.PURITY_TIMEOUT ?? 45000);
    const concurrency = Math.max(1, Math.min(64, opts?.concurrency ?? 24));
    const maxFiles = Math.max(1, opts?.maxFiles ?? 2500);

    // inner controller that we actually pass to IO calls
    const ac = new AbortController();

    // if an outer signal is provided, propagate aborts
    const propagateAbort = () => {
      if (opts?.signal?.aborted) ac.abort(opts.signal.reason);
    };
    if (opts?.signal) opts.signal.addEventListener('abort', propagateAbort);

    // time out the whole scan
    const timer = setTimeout(
      () => ac.abort(new Error(`purity-scan timed out after ${timeoutMs}ms`)),
      timeoutMs
    );

    try {
      const files = await findProjectFiles({
        cwd: this.opts?.cwd,
        patterns: opts?.patterns,
        maxDepth: 12,
      });

      if (opts?.verbose) console.log(`🔎 Purity: matched ${files.length} files`);

      const limited = files.slice(0, maxFiles);
      if (files.length > limited.length && opts?.verbose) {
        console.log(`ℹ️ Limiting scan to first ${limited.length} files (use --max-files to adjust)`);
      }

      let analyzed = 0;
      await mapLimit(limited, concurrency, async (file, i) => {
        if (ac.signal.aborted) throw ac.signal.reason;
        const ext = path.extname(file);
        if (!/\.[jt]sx?$/.test(ext)) return;
        
        const src = await fs.readFile(file, 'utf8');
        if (ac.signal.aborted) throw ac.signal.reason;
        
        this.analyzeSource(file, src);
        analyzed++;
        
        if (opts?.verbose && analyzed % 200 === 0) {
          console.log(`…analyzed ${analyzed}/${limited.length}`);
        }
      });

      return this.buildReport(analyzed);
    } finally {
      clearTimeout(timer);
      if (opts?.signal) opts.signal.removeEventListener('abort', propagateAbort);
    }
  }

  private analyzeSource(file: string, src: string) {
    const relativePath = path.relative(this.opts?.cwd ?? process.cwd(), file);
    const origin = this.detectOrigin(src);
    const category = this.categorizeFile(relativePath);

    if (category && this.results[category]) {
      this.results[category].total++;
      
      if (origin === 'kiro') {
        this.results[category].kiro++;
      } else if (origin === 'legacy') {
        this.results[category].legacy++;
        this.violations.push({
          type: 'component',
          severity: category === 'auth' ? 'critical' : 'high',
          file: relativePath,
          description: `${category} component contains legacy patterns`
        });
      }
    }

    // Check for API patterns
    if (this.containsAPIDefinitions(src)) {
      this.results.apis.total++;
      if (origin === 'kiro') {
        this.results.apis.kiro++;
      } else if (origin === 'legacy') {
        this.results.apis.legacy++;
        this.violations.push({
          type: 'api',
          severity: 'high',
          file: relativePath,
          description: 'API file contains legacy patterns'
        });
      }
    }
  }

  private detectOrigin(content: string): 'kiro' | 'legacy' | 'unknown' {
    const lowerContent = content.toLowerCase();
    
    // Check for Kiro markers
    if (this.kiroMarkers.some(marker => lowerContent.includes(marker.toLowerCase()))) {
      return 'kiro';
    }
    
    // Check for legacy markers
    if ([...this.supabaseMarkers, ...this.lovableMarkers].some(marker => 
      lowerContent.includes(marker.toLowerCase())
    )) {
      return 'legacy';
    }
    
    return 'unknown';
  }

  private categorizeFile(filePath: string): keyof typeof this.results | null {
    const lowerPath = filePath.toLowerCase();
    
    if (lowerPath.includes('/auth/') || lowerPath.includes('auth.')) {
      return 'auth';
    }
    if (lowerPath.includes('/dashboard/') || lowerPath.includes('dashboard.')) {
      return 'dashboard';
    }
    if (lowerPath.includes('/upload/') || lowerPath.includes('upload.')) {
      return 'upload';
    }
    if (lowerPath.includes('/vc/') || lowerPath.includes('visibility')) {
      return 'vc';
    }
    
    return null;
  }

  private containsAPIDefinitions(content: string): boolean {
    const apiPatterns = [
      /app\.(get|post|put|delete|patch)/,
      /router\.(get|post|put|delete|patch)/,
      /export.*handler/,
      /export.*api/,
      /\/api\//,
      /fetch\(/,
      /axios\./,
      /createClient/
    ];
    
    return apiPatterns.some(pattern => pattern.test(content));
  }

  private buildReport(filesAnalyzed: number): PurityScanResult {
    // Calculate scores for each category
    Object.keys(this.results).forEach(key => {
      const category = this.results[key as keyof typeof this.results];
      if ('total' in category && category.total > 0) {
        category.score = Math.round((category.kiro / category.total) * 100);
      } else if ('total' in category) {
        category.score = 100; // No files means no legacy contamination
      }
    });

    // Check test configuration
    this.checkTestConfiguration();

    // Calculate overall score
    const weights = {
      apis: 0.25,
      auth: 0.20,
      dashboard: 0.15,
      upload: 0.10,
      vc: 0.15,
      tests: 0.15
    };

    const overallScore = Math.round(
      this.results.apis.score * weights.apis +
      this.results.auth.score * weights.auth +
      this.results.dashboard.score * weights.dashboard +
      this.results.upload.score * weights.upload +
      this.results.vc.score * weights.vc +
      this.results.tests.score * weights.tests
    );

    const isPure = overallScore >= 95 && this.violations.filter(v => v.severity === 'critical').length === 0;

    return {
      success: true,
      score: overallScore,
      violations: this.violations,
      components: this.results,
      filesAnalyzed,
      timestamp: new Date().toISOString()
    };
  }

  private async checkTestConfiguration() {
    const testConfigs = ['jest.config.js', 'jest.config.cjs', 'jest.config.ts'];
    const cwd = this.opts?.cwd ?? process.cwd();
    
    for (const config of testConfigs) {
      try {
        await fs.access(path.join(cwd, config));
        this.results.tests.configured = true;
        this.results.tests.score = 100;
        return;
      } catch {
        // File doesn't exist, continue
      }
    }
    
    this.violations.push({
      type: 'test',
      severity: 'medium',
      file: 'test configuration',
      description: 'No test configuration found'
    });
    this.results.tests.score = 0;
  }
}