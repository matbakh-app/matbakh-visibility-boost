/**
 * Origin Detection Logic
 * Identifies component origins based on markers, imports, and patterns
 */

import { ComponentOrigin, OriginMarker } from './types';

export class OriginDetector {
  private static readonly ORIGIN_MARKERS: OriginMarker[] = [
    // Lovable markers
    {
      type: 'comment',
      pattern: /\/\*\*?\s*@lovable/i,
      origin: 'lovable',
      confidence: 0.9
    },
    {
      type: 'comment',
      pattern: /\/\/\s*lovable/i,
      origin: 'lovable',
      confidence: 0.8
    },
    {
      type: 'import',
      pattern: /from\s+['"]@\/lovable/,
      origin: 'lovable',
      confidence: 0.9
    },
    {
      type: 'pattern',
      pattern: /lovable-uploads/i,
      origin: 'lovable',
      confidence: 0.7
    },

    // Supabase markers
    {
      type: 'comment',
      pattern: /\/\*\*?\s*@supabase/i,
      origin: 'supabase',
      confidence: 0.9
    },
    {
      type: 'comment',
      pattern: /\/\/\s*supabase/i,
      origin: 'supabase',
      confidence: 0.8
    },
    {
      type: 'import',
      pattern: /from\s+['"]@supabase/,
      origin: 'supabase',
      confidence: 0.9
    },
    {
      type: 'import',
      pattern: /from\s+['"].*supabase/,
      origin: 'supabase',
      confidence: 0.8
    },
    {
      type: 'pattern',
      pattern: /createClient.*supabase/i,
      origin: 'supabase',
      confidence: 0.8
    },
    {
      type: 'pattern',
      pattern: /\.from\(['"].*['"]?\)/,
      origin: 'supabase',
      confidence: 0.6
    },

    // Kiro markers
    {
      type: 'comment',
      pattern: /\/\*\*?\s*@kiro/i,
      origin: 'kiro',
      confidence: 0.9
    },
    {
      type: 'comment',
      pattern: /\/\/\s*kiro/i,
      origin: 'kiro',
      confidence: 0.8
    },
    {
      type: 'comment',
      pattern: /generated by kiro/i,
      origin: 'kiro',
      confidence: 0.9
    },
    {
      type: 'import',
      pattern: /from\s+['"]@\/integrations\/aws/,
      origin: 'kiro',
      confidence: 0.8
    },
    {
      type: 'pattern',
      pattern: /aws-sdk/i,
      origin: 'kiro',
      confidence: 0.6
    },
    {
      type: 'pattern',
      pattern: /bedrock|cognito/i,
      origin: 'kiro',
      confidence: 0.7
    }
  ];

  /**
   * Detect the origin of a component based on file content
   */
  static detectOrigin(filePath: string, content: string): {
    origin: ComponentOrigin;
    confidence: number;
    markers: string[];
  } {
    const detections: Array<{
      origin: ComponentOrigin;
      confidence: number;
      marker: string;
    }> = [];

    // Check each marker against the content
    for (const marker of this.ORIGIN_MARKERS) {
      let matches = false;
      
      if (typeof marker.pattern === 'string') {
        matches = content.includes(marker.pattern);
      } else {
        matches = marker.pattern.test(content);
      }

      if (matches) {
        detections.push({
          origin: marker.origin,
          confidence: marker.confidence,
          marker: marker.pattern.toString()
        });
      }
    }

    // Additional filename-based detection
    const filename = filePath.toLowerCase();
    if (filename.includes('supabase')) {
      detections.push({
        origin: 'supabase',
        confidence: 0.7,
        marker: 'filename:supabase'
      });
    }
    if (filename.includes('lovable')) {
      detections.push({
        origin: 'lovable',
        confidence: 0.7,
        marker: 'filename:lovable'
      });
    }

    // Calculate weighted origin
    if (detections.length === 0) {
      return {
        origin: 'unknown',
        confidence: 0,
        markers: []
      };
    }

    // Group by origin and calculate total confidence
    const originScores = new Map<ComponentOrigin, number>();
    const originMarkers = new Map<ComponentOrigin, string[]>();

    for (const detection of detections) {
      const currentScore = originScores.get(detection.origin) || 0;
      originScores.set(detection.origin, currentScore + detection.confidence);
      
      const markers = originMarkers.get(detection.origin) || [];
      markers.push(detection.marker);
      originMarkers.set(detection.origin, markers);
    }

    // Find the origin with highest confidence
    let bestOrigin: ComponentOrigin = 'unknown';
    let bestScore = 0;
    let bestMarkers: string[] = [];

    for (const [origin, score] of originScores.entries()) {
      if (score > bestScore) {
        bestOrigin = origin;
        bestScore = score;
        bestMarkers = originMarkers.get(origin) || [];
      }
    }

    return {
      origin: bestOrigin,
      confidence: Math.min(bestScore, 1.0), // Cap at 1.0
      markers: bestMarkers
    };
  }

  /**
   * Detect Kiro alternatives for legacy components
   */
  static findKiroAlternative(filePath: string, origin: ComponentOrigin): string | undefined {
    if (origin === 'kiro') return undefined;

    const alternatives: Record<string, string> = {
      // Auth alternatives
      'src/pages/Login.tsx': 'src/components/auth/KiroLogin.tsx',
      'src/services/supabase-auth.ts': 'src/services/cognito-auth.ts',
      'src/contexts/SupabaseAuthContext.tsx': 'src/contexts/AuthContext.tsx',
      
      // API alternatives
      'src/services/supabase-client.ts': 'src/services/aws-rds-client.ts',
      'src/lib/supabase.ts': 'src/integrations/aws/client.ts',
      
      // Upload alternatives
      'src/components/upload/SupabaseUpload.tsx': 'src/components/upload/S3Upload.tsx',
      'src/services/file-upload.ts': 'src/services/s3-upload.ts',
      
      // Dashboard alternatives
      'src/pages/dashboard/LovableDashboard.tsx': 'src/pages/dashboard/KiroDashboard.tsx',
      'src/components/dashboard/LegacyCharts.tsx': 'src/components/analytics/ModernCharts.tsx'
    };

    return alternatives[filePath];
  }
}