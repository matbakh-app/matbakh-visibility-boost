/**
 * Tests for Architecture Compliance Checker
 */

import { describe, it, expect, beforeEach, afterEach } from '@jest/globals';
import { promises as fs } from 'fs';
import path from 'path';
import { ArchitectureComplianceChecker } from '../architecture-compliance-checker';

describe('ArchitectureComplianceChecker', () => {
  let checker: ArchitectureComplianceChecker;
  let tempDir: string;

  beforeEach(async () => {
    checker = new ArchitectureComplianceChecker();
    tempDir = path.join(__dirname, 'temp-compliance-test');
    await fs.mkdir(tempDir, { recursive: true });
  });

  afterEach(async () => {
    try {
      await fs.rm(tempDir, { recursive: true, force: true });
    } catch (error) {
      // Ignore cleanup errors
    }
  });

  describe('Supabase Import Detection', () => {
    it('should detect Supabase imports', async () => {
      const testFile = path.join(tempDir, 'test-component.tsx');
      await fs.writeFile(testFile, `
        import { createClient } from '@supabase/supabase-js';
        import React from 'react';
        
        const supabase = createClient('url', 'key');
        
        export default function TestComponent() {
          const data = supabase.from('table').select('*');
          return <div>Test</div>;
        }
      `);

      const report = await checker.checkCompliance(tempDir);
      
      expect(report.totalViolations).toBeGreaterThan(0);
      expect(report.violationsBySeverity.error).toBeGreaterThan(0);
      
      const supabaseViolations = report.violations.filter(v => v.ruleId === 'no-supabase-imports');
      expect(supabaseViolations.length).toBeGreaterThan(0);
      expect(supabaseViolations[0].message).toContain('Supabase import detected');
    });

    it('should not flag Kiro-based imports', async () => {
      const testFile = path.join(tempDir, 'kiro-component.tsx');
      await fs.writeFile(testFile, `
        import React from 'react';
        import { useKiroAuth } from '@/hooks/useKiroAuth';
        import { KiroApiClient } from '@/services/KiroApiClient';
        
        export default function KiroComponent() {
          const auth = useKiroAuth();
          return <div>Kiro Component</div>;
        }
      `);

      const report = await checker.checkCompliance(tempDir);
      
      const supabaseViolations = report.violations.filter(v => v.ruleId === 'no-supabase-imports');
      expect(supabaseViolations.length).toBe(0);
    });
  });

  describe('Lovable Pattern Detection', () => {
    it('should detect Lovable patterns', async () => {
      const testFile = path.join(tempDir, 'lovable-component.tsx');
      await fs.writeFile(testFile, `
        // Generated by Lovable
        import React from 'react';
        import { lovable-ui } from 'lovable-component';
        
        export default function LovableComponent() {
          return <div className="lovable-generated">Test</div>;
        }
      `);

      const report = await checker.checkCompliance(tempDir);
      
      const lovableViolations = report.violations.filter(v => v.ruleId === 'no-lovable-patterns');
      expect(lovableViolations.length).toBeGreaterThan(0);
      expect(lovableViolations[0].message).toContain('Lovable pattern detected');
    });
  });

  describe('Archived Import Detection', () => {
    it('should detect imports from archived directories', async () => {
      const testFile = path.join(tempDir, 'bad-import.tsx');
      await fs.writeFile(testFile, `
        import React from 'react';
        import { OldComponent } from '../src/archive/legacy-cleanup-2025-09-18/components/OldComponent';
        import { DeprecatedService } from '../src/deprecated/services/DeprecatedService';
        
        export default function BadImportComponent() {
          return <div>Bad Import</div>;
        }
      `);

      const report = await checker.checkCompliance(tempDir);
      
      const archivedViolations = report.violations.filter(v => v.ruleId === 'no-archived-imports');
      expect(archivedViolations.length).toBeGreaterThan(0);
      expect(archivedViolations[0].message).toContain('archived/deprecated directory');
    });
  });

  describe('Security Checks', () => {
    it('should detect hardcoded secrets', async () => {
      const testFile = path.join(tempDir, 'insecure-config.ts');
      await fs.writeFile(testFile, `
        export const config = {
          apiKey: 'sk_test_123456789abcdef',
          password: 'hardcoded-password',
          secret: 'my-secret-key'
        };
      `);

      const report = await checker.checkCompliance(tempDir);
      
      const secretViolations = report.violations.filter(v => v.ruleId === 'no-hardcoded-secrets');
      expect(secretViolations.length).toBeGreaterThan(0);
      expect(secretViolations[0].message).toContain('hardcoded secret');
    });

    it('should allow environment variables', async () => {
      const testFile = path.join(tempDir, 'secure-config.ts');
      await fs.writeFile(testFile, `
        export const config = {
          apiKey: process.env.API_KEY,
          password: process.env.PASSWORD,
          secret: process.env.SECRET_KEY
        };
      `);

      const report = await checker.checkCompliance(tempDir);
      
      const secretViolations = report.violations.filter(v => v.ruleId === 'no-hardcoded-secrets');
      expect(secretViolations.length).toBe(0);
    });

    it('should detect HTTP URLs in production code', async () => {
      const testFile = path.join(tempDir, 'insecure-api.ts');
      await fs.writeFile(testFile, `
        const API_URL = 'http://api.example.com';
        
        export async function fetchData() {
          return fetch(API_URL);
        }
      `);

      const report = await checker.checkCompliance(tempDir);
      
      const secureViolations = report.violations.filter(v => v.ruleId === 'secure-api-patterns');
      expect(secureViolations.length).toBeGreaterThan(0);
      expect(secureViolations[0].message).toContain('HTTP URL detected');
    });
  });

  describe('Component Structure Checks', () => {
    it('should warn about components without proper exports', async () => {
      const componentsDir = path.join(tempDir, 'components');
      await fs.mkdir(componentsDir, { recursive: true });
      
      const testFile = path.join(componentsDir, 'BadComponent.tsx');
      await fs.writeFile(testFile, `
        import React from 'react';
        
        function BadComponent() {
          return <div>No export</div>;
        }
      `);

      const report = await checker.checkCompliance(tempDir);
      
      const structureViolations = report.violations.filter(v => v.ruleId === 'proper-component-structure');
      expect(structureViolations.length).toBeGreaterThan(0);
      expect(structureViolations[0].message).toContain('default or named export');
    });

    it('should pass for properly structured components', async () => {
      const componentsDir = path.join(tempDir, 'components');
      await fs.mkdir(componentsDir, { recursive: true });
      
      const testFile = path.join(componentsDir, 'GoodComponent.tsx');
      await fs.writeFile(testFile, `
        import React from 'react';
        
        interface GoodComponentProps {
          title: string;
        }
        
        export default function GoodComponent({ title }: GoodComponentProps) {
          return <div>{title}</div>;
        }
      `);

      const report = await checker.checkCompliance(tempDir);
      
      const structureViolations = report.violations.filter(v => 
        v.ruleId === 'proper-component-structure' && v.file?.includes('GoodComponent.tsx')
      );
      expect(structureViolations.length).toBe(0);
    });
  });

  describe('Performance Checks', () => {
    it('should suggest efficient lodash imports', async () => {
      const testFile = path.join(tempDir, 'inefficient-imports.ts');
      await fs.writeFile(testFile, `
        import _ from 'lodash';
        
        export function processData(data: any[]) {
          return _.map(data, item => item.id);
        }
      `);

      const report = await checker.checkCompliance(tempDir);
      
      const performanceViolations = report.violations.filter(v => v.ruleId === 'efficient-imports');
      expect(performanceViolations.length).toBeGreaterThan(0);
      expect(performanceViolations[0].message).toContain('tree shaking');
    });
  });

  describe('Naming Convention Checks', () => {
    it('should check component file naming', async () => {
      const componentsDir = path.join(tempDir, 'components');
      await fs.mkdir(componentsDir, { recursive: true });
      
      const testFile = path.join(componentsDir, 'badComponentName.tsx');
      await fs.writeFile(testFile, `
        import React from 'react';
        export default function BadComponentName() {
          return <div>Bad naming</div>;
        }
      `);

      const report = await checker.checkCompliance(tempDir);
      
      const namingViolations = report.violations.filter(v => v.ruleId === 'consistent-naming');
      expect(namingViolations.length).toBeGreaterThan(0);
      expect(namingViolations[0].message).toContain('uppercase letter');
    });

    it('should check service file naming', async () => {
      const servicesDir = path.join(tempDir, 'services');
      await fs.mkdir(servicesDir, { recursive: true });
      
      const testFile = path.join(servicesDir, 'api-client.ts');
      await fs.writeFile(testFile, `
        export class ApiClient {
          async fetchData() {
            return {};
          }
        }
      `);

      const report = await checker.checkCompliance(tempDir);
      
      const namingViolations = report.violations.filter(v => 
        v.ruleId === 'consistent-naming' && v.file?.includes('api-client.ts')
      );
      expect(namingViolations.length).toBeGreaterThan(0);
      expect(namingViolations[0].message).toContain('Service');
    });
  });

  describe('Report Generation', () => {
    it('should generate comprehensive report', async () => {
      const testFile = path.join(tempDir, 'mixed-violations.tsx');
      await fs.writeFile(testFile, `
        import { createClient } from '@supabase/supabase-js';
        import React from 'react';
        
        const API_KEY = 'sk_test_123456789';
        const supabase = createClient('url', API_KEY);
        
        export default function MixedViolations() {
          return <div>Mixed violations</div>;
        }
      `);

      const report = await checker.checkCompliance(tempDir);
      
      expect(report.timestamp).toBeDefined();
      expect(report.totalFiles).toBeGreaterThan(0);
      expect(report.totalViolations).toBeGreaterThan(0);
      expect(report.violationsBySeverity).toBeDefined();
      expect(report.violationsByCategory).toBeDefined();
      expect(report.summary).toBeDefined();
      expect(report.violations.length).toBeGreaterThan(0);
      
      // Should have both architecture and security violations
      expect(report.violationsByCategory.architecture).toBeGreaterThan(0);
      expect(report.violationsByCategory.security).toBeGreaterThan(0);
    });

    it('should generate clean report for compliant code', async () => {
      const testFile = path.join(tempDir, 'clean-code.tsx');
      await fs.writeFile(testFile, `
        import React from 'react';
        import { useKiroAuth } from '@/hooks/useKiroAuth';
        
        interface CleanComponentProps {
          title: string;
        }
        
        export default function CleanComponent({ title }: CleanComponentProps) {
          const auth = useKiroAuth();
          return <div>{title}</div>;
        }
      `);

      const report = await checker.checkCompliance(tempDir);
      
      expect(report.totalViolations).toBe(0);
      expect(report.violationsBySeverity.error).toBe(0);
      expect(report.summary).toContain('compliance check passed');
    });
  });
});