/**
 * Tests for Kiro System Purity Validator
 */

import { describe, it, expect, beforeEach, afterEach, jest } from '@jest/globals';
import { promises as fs } from 'fs';
import path from 'path';
import fg from 'fast-glob';
import { KiroSystemPurityValidator } from '../kiro-system-purity-validator';

import fg from 'fast-glob';

jest.mock('node:fs/promises', () => {
  const readFile = jest.fn();
  const writeFile = jest.fn();
  const mkdir = jest.fn();
  return { __esModule: true, default: { readFile, writeFile, mkdir }, readFile, writeFile, mkdir };
});

jest.mock('fast-glob', () => {
  const mock: any = jest.fn().mockResolvedValue([]); // async default: []
  mock.sync = jest.fn(() => []);                      // sync default: []
  return { __esModule: true, default: mock, sync: mock.sync };
});

import * as fsProm from 'node:fs/promises';
const mockReadFile = fsProm.readFile as unknown as jest.Mock;
const mockWriteFile = fsProm.writeFile as unknown as jest.Mock;
const mockMkdir = fsProm.mkdir as unknown as jest.Mock;
const mockFs = { readFile: mockReadFile, writeFile: mockWriteFile, mkdir: mockMkdir };
const mockGlob = fg as unknown as jest.Mock & { sync: jest.Mock };

describe('KiroSystemPurityValidator', () => {
  let validator: KiroSystemPurityValidator;
  const mockWorkspaceRoot = '/mock/workspace';

  beforeEach(() => {
    validator = new KiroSystemPurityValidator(mockWorkspaceRoot);
    mockGlob.mockReset().mockResolvedValue([]);
    mockGlob.sync.mockReset().mockReturnValue([]);
    mockReadFile.mockReset();
    mockWriteFile.mockReset();
    mockMkdir.mockReset();
  });

  afterEach(() => {
    jest.resetAllMocks();
  });

  describe('validateSystemPurity', () => {
    it('should validate a pure Kiro system', async () => {
      // --- Arrange: simuliere ein vollständig „pures" Kiro-Workspace ---
      // Wichtig: Reihenfolge der glob-Calls exakt wie im Validator:
      // 1) APIs -> 2) Kategorien: auth, dashboard, upload, vc (jede Kategorie macht mehrere Calls)
      mockGlob.mockReset();
      mockGlob
        .mockResolvedValueOnce(['src/services/kiro-api.ts'])                    // validateAPIs()
        .mockResolvedValueOnce(['src/components/auth/KiroAuth.tsx'])            // auth pattern 1
        .mockResolvedValueOnce(['src/components/dashboard/KiroDashboard.tsx'])  // dashboard pattern 1  
        .mockResolvedValueOnce(['src/components/upload/KiroUpload.tsx'])        // upload pattern 1
        .mockResolvedValueOnce(['src/components/vc/KiroVC.tsx']);               // vc pattern 1

      // Falls irgendwo sync-Variante benutzt wird: keine Legacy-Dateien
      if (typeof (mockGlob as any).sync === 'function') {
        (mockGlob as any).sync.mockReset?.();
        (mockGlob as any).sync.mockReturnValue?.([]);
      }

      // Alle gelesenen Dateien tragen klare Kiro-Signaturen + gültige Exports
      mockReadFile.mockReset();
      mockReadFile.mockImplementation(async (p: string) => {
        if (p.endsWith('src/services/kiro-api.ts')) {
          return `// Generated by Kiro
export const handler = () => {};
fetch('/api/hello');`;
        }
        if (p.endsWith('src/components/auth/KiroAuth.tsx')) {
          return `// Generated by Kiro
export default function KiroAuth(){ return null }`;
        }
        if (p.endsWith('src/components/dashboard/KiroDashboard.tsx')) {
          return `// Generated by Kiro
export const KiroDashboard = () => null`;
        }
        if (p.endsWith('src/components/upload/KiroUpload.tsx')) {
          return `// Generated by Kiro
export const KiroUpload = () => null`;
        }
        if (p.endsWith('src/components/vc/KiroVC.tsx')) {
          return `// Generated by Kiro
export const KiroVC = () => null`;
        }
        if (p.endsWith('vitest.config.ts')) {
          return `import { defineConfig } from 'vitest/config';
// Kiro test configuration
export default defineConfig({ test: { globals: true } });`;
        }
        // Für alle anderen Config-Dateien: leere Antwort (sie existieren nicht)
        if (p.includes('jest.config') || p.includes('playwright.config') || p.endsWith('vitest.config.js')) {
          throw new Error('ENOENT: no such file or directory');
        }
        return '';
      });

      // --- Act ---
      const result = await validator.validateSystemPurity();

      // --- Assert ---
      expect(result.isPure).toBe(true);
      expect(result.score).toBeGreaterThanOrEqual(95);
      expect(result.violations).toHaveLength(0);
      expect(result.certification).toBeTruthy();
      expect(result.certification?.certified).toBe(true);
    });

    it('should detect legacy Supabase components', async () => {
      // Mock file discovery - need to mock all glob calls
      mockGlob
        .mockResolvedValueOnce(['src/services/supabase-api.ts']) // APIs
        .mockResolvedValueOnce(['src/components/auth/SupabaseAuth.tsx']) // Auth patterns[0]
        .mockResolvedValueOnce([]) // Auth patterns[1]
        .mockResolvedValueOnce([]) // Auth patterns[2]
        .mockResolvedValueOnce([]) // Auth patterns[3]
        .mockResolvedValueOnce([]) // Dashboard patterns[0]
        .mockResolvedValueOnce([]) // Dashboard patterns[1]
        .mockResolvedValueOnce([]) // Dashboard patterns[2]
        .mockResolvedValueOnce([]) // Dashboard patterns[3]
        .mockResolvedValueOnce([]) // Upload patterns[0]
        .mockResolvedValueOnce([]) // Upload patterns[1]
        .mockResolvedValueOnce([]) // Upload patterns[2]
        .mockResolvedValueOnce([]) // Upload patterns[3]
        .mockResolvedValueOnce([]) // VC patterns[0]
        .mockResolvedValueOnce([]) // VC patterns[1]
        .mockResolvedValueOnce([]) // VC patterns[2]
        .mockResolvedValueOnce([]) // VC patterns[3]
        .mockResolvedValueOnce([]); // VC patterns[4]

      // Mock file contents - Supabase legacy with proper markers
      mockFs.readFile
        .mockResolvedValueOnce('import { createClient } from "@supabase/supabase-js"; // Supabase API')
        .mockResolvedValueOnce('import { supabase } from "../lib/supabase"; // Supabase component');

      const result = await validator.validateSystemPurity();

      expect(result.isPure).toBe(false);
      expect(result.score).toBeLessThan(95);
      expect(result.violations.length).toBeGreaterThan(0);
      // Should find violations in the files we mocked
      const hasApiViolation = result.violations.some(v => v.file === 'src/services/supabase-api.ts');
      const hasComponentViolation = result.violations.some(v => v.file === 'src/components/auth/SupabaseAuth.tsx');
      expect(hasApiViolation || hasComponentViolation).toBe(true);
      expect(result.certification).toBeNull();
    });

    it('should detect Lovable components', async () => {
      mockGlob
        .mockResolvedValueOnce([]) // APIs
        .mockResolvedValueOnce(['src/components/auth/LovableAuth.tsx']) // Auth patterns[0]
        .mockResolvedValueOnce([]) // Auth patterns[1]
        .mockResolvedValueOnce([]) // Auth patterns[2]
        .mockResolvedValueOnce([]) // Auth patterns[3]
        .mockResolvedValueOnce([]) // Dashboard patterns[0]
        .mockResolvedValueOnce([]) // Dashboard patterns[1]
        .mockResolvedValueOnce([]) // Dashboard patterns[2]
        .mockResolvedValueOnce([]) // Dashboard patterns[3]
        .mockResolvedValueOnce([]) // Upload patterns[0]
        .mockResolvedValueOnce([]) // Upload patterns[1]
        .mockResolvedValueOnce([]) // Upload patterns[2]
        .mockResolvedValueOnce([]) // Upload patterns[3]
        .mockResolvedValueOnce([]) // VC patterns[0]
        .mockResolvedValueOnce([]) // VC patterns[1]
        .mockResolvedValueOnce([]) // VC patterns[2]
        .mockResolvedValueOnce([]) // VC patterns[3]
        .mockResolvedValueOnce([]); // VC patterns[4]

      mockFs.readFile
        .mockResolvedValueOnce('// Lovable generated component\nexport const LovableAuth = () => {};');

      const result = await validator.validateSystemPurity();

      expect(result.violations.some(v => v.file === 'src/components/auth/LovableAuth.tsx')).toBe(true);
    });

    it('should handle mixed system with partial purity', async () => {
      mockGlob
        .mockResolvedValueOnce(['src/services/kiro-api.ts', 'src/services/legacy-api.ts']) // APIs
        .mockResolvedValueOnce(['src/components/auth/KiroAuth.tsx']) // Auth patterns[0]
        .mockResolvedValueOnce([]) // Auth patterns[1]
        .mockResolvedValueOnce([]) // Auth patterns[2]
        .mockResolvedValueOnce([]) // Auth patterns[3]
        .mockResolvedValueOnce(['src/components/dashboard/LegacyDashboard.tsx']) // Dashboard patterns[0]
        .mockResolvedValueOnce([]) // Dashboard patterns[1]
        .mockResolvedValueOnce([]) // Dashboard patterns[2]
        .mockResolvedValueOnce([]) // Dashboard patterns[3]
        .mockResolvedValueOnce([]) // Upload patterns[0]
        .mockResolvedValueOnce([]) // Upload patterns[1]
        .mockResolvedValueOnce([]) // Upload patterns[2]
        .mockResolvedValueOnce([]) // Upload patterns[3]
        .mockResolvedValueOnce(['src/components/vc/KiroVC.tsx']) // VC patterns[0]
        .mockResolvedValueOnce([]) // VC patterns[1]
        .mockResolvedValueOnce([]) // VC patterns[2]
        .mockResolvedValueOnce([]) // VC patterns[3]
        .mockResolvedValueOnce([]); // VC patterns[4]

      mockFs.readFile
        .mockResolvedValueOnce('// Generated by Kiro\nexport const api = {}')
        .mockResolvedValueOnce('// Legacy API\nexport const legacyApi = {}')
        .mockResolvedValueOnce('// Kiro-generated\nexport const KiroAuth = () => {}')
        .mockResolvedValueOnce('// Legacy dashboard\nexport const LegacyDashboard = () => {}')
        .mockResolvedValueOnce('// kiro-service\nexport const KiroVC = () => {}');

      const result = await validator.validateSystemPurity();

      expect(result.score).toBeGreaterThan(0);
      expect(result.score).toBeLessThan(100);
      expect(result.violations.length).toBeGreaterThan(0);
    });
  });

  describe('validateAPIs', () => {
    it('should identify Kiro APIs correctly', async () => {
      mockGlob.mockResolvedValueOnce(['src/services/api.ts']);
      mockFs.readFile.mockResolvedValueOnce(`
        // Generated by Kiro
        export const handler = async (req, res) => {
          // API implementation
        };
      `);

      const result = await (validator as any).validateAPIs();

      expect(result.totalAPIs).toBe(1);
      expect(result.kiroAPIs).toBe(1);
      expect(result.legacyAPIs).toBe(0);
      expect(result.purityScore).toBe(100);
    });

    it('should detect Supabase API patterns', async () => {
      mockGlob.mockResolvedValueOnce(['src/services/supabase-api.ts']);
      mockFs.readFile.mockResolvedValueOnce(`
        import { createClient } from '@supabase/supabase-js';
        const supabase = createClient(supabaseUrl, supabaseKey);
      `);

      const result = await (validator as any).validateAPIs();

      expect(result.legacyAPIs).toBe(1);
      expect(result.details[0].origin).toBe('supabase');
    });

    it('should extract API endpoints', async () => {
      mockGlob.mockResolvedValueOnce(['src/services/api.ts']);
      mockFs.readFile.mockResolvedValueOnce(`
        // Kiro-generated
        fetch('/api/users');
        fetch('/api/restaurants');
      `);

      const result = await (validator as any).validateAPIs();

      expect(result.details[0].endpoints).toContain('/api/users');
      expect(result.details[0].endpoints).toContain('/api/restaurants');
    });
  });

  describe('validateTestFrameworks', () => {
    it('should validate Kiro test configuration', async () => {
      mockFs.readFile.mockResolvedValueOnce(`
        // Kiro test configuration
        module.exports = {
          preset: 'ts-jest',
          testEnvironment: 'jsdom',
          setupFilesAfterEnv: ['<rootDir>/src/setupTests.ts'],
          moduleNameMapper: {
            '^@/(.*)$': '<rootDir>/src/$1'
          },
          testPathIgnorePatterns: ['/archive/']
        };
      `);

      const result = await (validator as any).validateTestFrameworks();

      expect(result.isKiroConfigured).toBe(true);
      expect(result.violations).toHaveLength(0);
      expect(result.purityScore).toBe(100);
    });

    it('should detect legacy test configuration', async () => {
      mockFs.readFile.mockResolvedValueOnce(`
        module.exports = {
          setupFilesAfterEnv: ['<rootDir>/src/supabase-test-setup.ts']
        };
      `);

      const result = await (validator as any).validateTestFrameworks();

      expect(result.isKiroConfigured).toBe(false);
      expect(result.violations.length).toBeGreaterThan(0);
    });
  });

  describe('validateComponentCategory', () => {
    it('should validate auth components', async () => {
      mockGlob.mockResolvedValueOnce(['src/components/auth/KiroAuth.tsx']);
      mockFs.readFile.mockResolvedValueOnce('// Kiro-generated\nexport const KiroAuth = () => {}');

      const result = await (validator as any).validateComponentCategory('auth', ['src/components/auth/**/*.{ts,tsx}']);

      expect(result.totalComponents).toBe(1);
      expect(result.kiroComponents).toBe(1);
      expect(result.purityScore).toBe(100);
    });

    it('should detect legacy components', async () => {
      mockGlob.mockResolvedValueOnce(['src/components/auth/SupabaseAuth.tsx']);
      mockFs.readFile.mockResolvedValueOnce('import { supabase } from "../lib/supabase"');

      const result = await (validator as any).validateComponentCategory('auth', ['src/components/auth/**/*.{ts,tsx}']);

      expect(result.legacyComponents).toBe(1);
      expect(result.details[0].origin).toBe('supabase');
    });
  });

  describe('detectOrigin', () => {
    it('should detect Kiro origin', () => {
      const content = '// Generated by Kiro\nexport const component = () => {}';
      const origin = (validator as any).detectOrigin(content);
      expect(origin).toBe('kiro');
    });

    it('should detect Supabase origin', () => {
      const content = 'import { createClient } from "@supabase/supabase-js"';
      const origin = (validator as any).detectOrigin(content);
      expect(origin).toBe('supabase');
    });

    it('should detect Lovable origin', () => {
      const content = '// Lovable generated component';
      const origin = (validator as any).detectOrigin(content);
      expect(origin).toBe('lovable');
    });

    it('should return unknown for unidentified content', () => {
      const content = 'export const component = () => {}';
      const origin = (validator as any).detectOrigin(content);
      expect(origin).toBe('unknown');
    });
  });

  describe('generateCertification', () => {
    it('should generate gold certification for score >= 98', () => {
      const cert = (validator as any).generateCertification(99);
      expect(cert.certified).toBe(true);
      expect(cert.certificationLevel).toBe('gold');
    });

    it('should generate silver certification for score >= 95', () => {
      const cert = (validator as any).generateCertification(96);
      expect(cert.certified).toBe(true);
      expect(cert.certificationLevel).toBe('silver');
    });

    it('should generate bronze certification for score >= 90', () => {
      const cert = (validator as any).generateCertification(92);
      expect(cert.certified).toBe(true);
      expect(cert.certificationLevel).toBe('bronze');
    });

    it('should fail certification for score < 90', () => {
      const cert = (validator as any).generateCertification(85);
      expect(cert.certified).toBe(false);
      expect(cert.certificationLevel).toBe('failed');
    });
  });

  describe('generatePurityReport', () => {
    it('should generate comprehensive report for pure system', async () => {
      const mockResult = {
        isPure: true,
        score: 98,
        timestamp: '2025-01-14T10:00:00Z',
        validations: {
          apis: { totalAPIs: 5, kiroAPIs: 5, legacyAPIs: 0, unknownAPIs: 0, purityScore: 100 },
          testFrameworks: { isKiroConfigured: true, configFiles: ['jest.config.js'], purityScore: 100 },
          authComponents: { totalComponents: 3, kiroComponents: 3, legacyComponents: 0, purityScore: 100 },
          dashboardComponents: { totalComponents: 2, kiroComponents: 2, legacyComponents: 0, purityScore: 100 },
          uploadComponents: { totalComponents: 1, kiroComponents: 1, legacyComponents: 0, purityScore: 100 },
          vcComponents: { totalComponents: 4, kiroComponents: 4, legacyComponents: 0, purityScore: 100 }
        },
        violations: [],
        recommendations: ['🎉 System is pure! All components are Kiro-based.'],
        certification: {
          certified: true,
          certificationLevel: 'gold' as const,
          issuedAt: '2025-01-14T10:00:00Z',
          validUntil: '2025-04-14T10:00:00Z',
          criteria: {
            apiPurity: true,
            testPurity: true,
            componentPurity: true,
            configurationPurity: true
          }
        }
      };

      const report = await validator.generatePurityReport(mockResult);

      expect(report).toContain('Kiro System Purity Certification Report');
      expect(report).toContain('Overall Score: 98/100');
      expect(report).toContain('System Status: ✅ PURE');
      expect(report).toContain('**CERTIFIED**: GOLD');
      expect(report).toContain('No violations found! 🎉');
    });

    it('should generate report with violations for impure system', async () => {
      const mockResult = {
        isPure: false,
        score: 75,
        timestamp: '2025-01-14T10:00:00Z',
        validations: {
          apis: { totalAPIs: 5, kiroAPIs: 3, legacyAPIs: 2, unknownAPIs: 0, purityScore: 60 },
          testFrameworks: { isKiroConfigured: false, configFiles: ['jest.config.js'], purityScore: 50 },
          authComponents: { totalComponents: 3, kiroComponents: 2, legacyComponents: 1, purityScore: 67 },
          dashboardComponents: { totalComponents: 2, kiroComponents: 2, legacyComponents: 0, purityScore: 100 },
          uploadComponents: { totalComponents: 1, kiroComponents: 1, legacyComponents: 0, purityScore: 100 },
          vcComponents: { totalComponents: 4, kiroComponents: 3, legacyComponents: 1, purityScore: 75 }
        },
        violations: [
          {
            type: 'api' as const,
            severity: 'high' as const,
            file: 'src/services/legacy-api.ts',
            description: 'API file contains supabase patterns',
            recommendation: 'Migrate to Kiro-generated API patterns'
          }
        ],
        recommendations: ['⚠️ Address 1 high-priority violations'],
        certification: null
      };

      const report = await validator.generatePurityReport(mockResult);

      expect(report).toContain('System Status: ❌ IMPURE');
      expect(report).toContain('HIGH: src/services/legacy-api.ts');
      expect(report).toContain('NOT CERTIFIED');
    });
  });

  describe('edge cases', () => {
    it('should handle empty workspace', async () => {
      // Mock all glob calls to return empty arrays
      mockGlob.mockResolvedValue([]);

      const result = await validator.validateSystemPurity();

      expect(result.score).toBeGreaterThanOrEqual(85); // Empty system scores high but not perfect due to missing test config
      expect(result.isPure).toBe(false); // Not pure due to missing test configuration
    });

    it('should handle file read errors gracefully', async () => {
      mockGlob.mockResolvedValueOnce(['src/services/api.ts']);
      mockFs.readFile.mockRejectedValueOnce(new Error('File not found'));

      const result = await (validator as any).validateAPIs();

      expect(result.totalAPIs).toBe(0); // File couldn't be read, so not counted
    });

    it('should handle malformed configuration files', async () => {
      mockFs.readFile.mockResolvedValueOnce('invalid javascript content {{{');

      const result = await (validator as any).validateTestFrameworks();

      expect(result.violations.length).toBeGreaterThan(0);
    });
  });
});