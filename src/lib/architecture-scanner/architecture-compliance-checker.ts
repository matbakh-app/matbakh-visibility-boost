import { z } from 'zod';
import * as fs from 'fs';
import * as path from 'path';

// Zod schemas for validation
const ComplianceViolationSchema = z.object({
  ruleId: z.string(),
  severity: z.enum(['error', 'warning', 'info']),
  message: z.string(),
  file: z.string().optional(),
  line: z.number().optional(),
  column: z.number().optional(),
});

const ComplianceReportSchema = z.object({
  timestamp: z.string(),
  totalFiles: z.number(),
  totalViolations: z.number(),
  violations: z.array(ComplianceViolationSchema),
  violationsBySeverity: z.object({
    error: z.number(),
    warning: z.number(),
    info: z.number(),
  }),
  violationsByCategory: z.record(z.number()).optional(),
  summary: z.string(),
});

export type ComplianceViolation = z.infer<typeof ComplianceViolationSchema>;
export type ComplianceReport = z.infer<typeof ComplianceReportSchema>;

interface ComplianceContext {
  files: string[];
  fileContents: Map<string, string>;
  projectRoot: string;
}

export class ArchitectureComplianceChecker {
  private projectRoot: string;

  constructor(projectRoot: string = process.cwd()) {
    this.projectRoot = projectRoot;
  }

  async checkCompliance(projectRoot?: string): Promise<ComplianceReport> {
    // Use provided projectRoot or fall back to instance projectRoot
    const rootPath = projectRoot || this.projectRoot;
    const context = await this.buildContext(rootPath);
    const violations: ComplianceViolation[] = [];

    // Run all compliance checks
    violations.push(...await this.checkKiroPatterns(context));
    violations.push(...await this.checkNamingConventions(context));
    violations.push(...await this.checkEfficientImports(context));
    violations.push(...await this.checkComponentStructure(context));

    return this.generateReport(violations, context.files.length);
  }

  private async buildContext(projectRoot?: string): Promise<ComplianceContext> {
    const rootPath = projectRoot || this.projectRoot;
    const files = await this.getAllFiles(rootPath);
    const fileContents = new Map<string, string>();

    for (const file of files) {
      try {
        const content = await fs.promises.readFile(file, 'utf-8');
        fileContents.set(file, content);
      } catch (error) {
        console.warn(`Failed to read file ${file}:`, error);
      }
    }

    return {
      files,
      fileContents,
      projectRoot: rootPath,
    };
  }

  private async getAllFiles(projectRoot?: string): Promise<string[]> {
    const rootPath = projectRoot || this.projectRoot;
    const files: string[] = [];
    const extensions = ['.ts', '.tsx', '.js', '.jsx'];

    const walkDir = async (dir: string): Promise<void> => {
      try {
        const entries = await fs.promises.readdir(dir, { withFileTypes: true });
        
        for (const entry of entries) {
          const fullPath = path.join(dir, entry.name);
          
          if (entry.isDirectory()) {
            // Skip certain directories
            if (!['node_modules', '.git', 'dist', 'build', 'archive'].includes(entry.name)) {
              await walkDir(fullPath);
            }
          } else if (entry.isFile()) {
            const ext = path.extname(entry.name);
            if (extensions.includes(ext)) {
              files.push(fullPath);
            }
          }
        }
      } catch (error) {
        console.warn(`Failed to read directory ${dir}:`, error);
      }
    };

    await walkDir(rootPath);
    return files;
  }

  private async checkKiroPatterns(context: ComplianceContext): Promise<ComplianceViolation[]> {
    const violations: ComplianceViolation[] = [];

    for (const [file, content] of context.fileContents) {
      // Check for Kiro-compliant patterns
      if (content.includes('// Generated by Kiro') || content.includes('/* Kiro-generated */')) {
        // This is good - Kiro-generated code
        continue;
      }

      // Check for legacy patterns that should be avoided
      const legacyPatterns = [
        { pattern: /@supabase\/supabase-js/, message: 'Supabase imports should be migrated to AWS services' },
        { pattern: /createClient.*supabase/, message: 'Supabase client usage should be replaced with AWS clients' },
        { pattern: /lovable-generated/, message: 'Lovable-generated code should be replaced with Kiro alternatives' },
      ];

      for (const { pattern, message } of legacyPatterns) {
        if (pattern.test(content)) {
          violations.push({
            ruleId: 'kiro-compliance',
            severity: 'warning',
            message,
            file: path.relative(this.projectRoot, file),
          });
        }
      }
    }

    return violations;
  }

  private async checkNamingConventions(context: ComplianceContext): Promise<ComplianceViolation[]> {
    const violations: ComplianceViolation[] = [];

    for (const file of context.files) {
      const fileName = path.basename(file);
      const relativePath = path.relative(this.projectRoot, file);

      // Check component naming conventions
      if (file.includes('/components/') && fileName.endsWith('.tsx')) {
        if (!/^[A-Z][a-zA-Z0-9]*\.tsx$/.test(fileName)) {
          violations.push({
            ruleId: 'consistent-naming',
            severity: 'warning',
            message: `Component file should start with uppercase letter: ${fileName}`,
            file: relativePath,
          });
        }
      }

      // Check service naming conventions
      if (file.includes('/services/') && fileName.endsWith('.ts')) {
        if (!/Service\.ts$/.test(fileName) && !fileName.includes('.test.')) {
          violations.push({
            ruleId: 'consistent-naming',
            severity: 'info',
            message: `Service file should end with 'Service.ts': ${fileName}`,
            file: relativePath,
          });
        }
      }
    }

    return violations;
  }

  private async checkEfficientImports(context: ComplianceContext): Promise<ComplianceViolation[]> {
    const violations: ComplianceViolation[] = [];

    for (const [file, content] of context.fileContents) {
      const relativePath = path.relative(this.projectRoot, file);

      // Check for inefficient imports
      const lines = content.split('\n');
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        
        // Check for wildcard imports that could be specific
        if (/import \* as .* from/.test(line) && !line.includes('React')) {
          violations.push({
            ruleId: 'efficient-imports',
            severity: 'info',
            message: 'Consider using specific imports instead of wildcard imports to enable tree shaking',
            file: relativePath,
            line: i + 1,
          });
        }
      }
    }

    return violations;
  }

  private async checkComponentStructure(context: ComplianceContext): Promise<ComplianceViolation[]> {
    const violations: ComplianceViolation[] = [];

    // Check component files in src/components/**/*.{ts,tsx}
    const componentFiles = context.files.filter(file => 
      file.includes('/components/') && (file.endsWith('.ts') || file.endsWith('.tsx'))
    );

    for (const file of componentFiles) {
      const content = context.fileContents.get(file);
      if (!content) continue;

      const relativePath = path.relative(this.projectRoot, file);
      
      // Check for exports
      const hasDefaultExport = /export\s+default\s+/.test(content);
      const hasNamedExport = /export\s+(const|function|class|interface|type)\s+/.test(content);
      
      if (!hasDefaultExport && !hasNamedExport) {
        violations.push({
          ruleId: 'proper-component-structure',
          severity: 'warning',
          message: 'Component should have a default or named export',
          file: relativePath,
        });
      }
    }

    return violations;
  }

  private generateReport(violations: ComplianceViolation[], totalFiles: number): ComplianceReport {
    const violationsBySeverity = violations.reduce(
      (acc, violation) => {
        acc[violation.severity]++;
        return acc;
      },
      { error: 0, warning: 0, info: 0 }
    );

    const violationsByCategory = violations.reduce((acc, violation) => {
      acc[violation.ruleId] = (acc[violation.ruleId] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    const summary = violations.length === 0 ? 'compliance check passed' : 'violations found';

    return {
      timestamp: new Date().toISOString(),
      totalFiles,
      totalViolations: violations.length,
      violations,
      violationsBySeverity,
      violationsByCategory,
      summary,
    };
  }
}

export default ArchitectureComplianceChecker;