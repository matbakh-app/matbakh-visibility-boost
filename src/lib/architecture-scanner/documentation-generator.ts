/**
 * Architecture Documentation Generator
 * 
 * Generates comprehensive architecture documentation including:
 * - Component overview with metadata
 * - Dependency analysis
 * - Risk assessment reports
 * - Cleanup recommendations
 * - Visual diagrams
 */

import { ArchitectureMap } from './types';
import { DependencyGraph } from './dependency-graph';
import { ComponentMap } from './component-map';
import { generateMermaidDiagram, generateMermaidVariants } from './mermaid-generator';
import fs from 'fs/promises';
import path from 'path';

export interface DocumentationConfig {
  outputDir: string;
  includeVisuals: boolean;
  includeDetailedAnalysis: boolean;
  generateVariants: boolean;
  format: 'markdown' | 'html' | 'both';
}

export class DocumentationGenerator {
  private config: DocumentationConfig;

  constructor(config: Partial<DocumentationConfig> = {}) {
    this.config = {
      outputDir: 'reports',
      includeVisuals: true,
      includeDetailedAnalysis: true,
      generateVariants: true,
      format: 'markdown',
      ...config
    };
  }

  /**
   * Generate complete architecture documentation
   */
  async generateDocumentation(
    architectureMap: ArchitectureMap,
    dependencyGraph?: DependencyGraph,
    componentMap?: ComponentMap
  ): Promise<void> {
    console.log('📚 Generating architecture documentation...');

    // Ensure output directory exists
    await fs.mkdir(this.config.outputDir, { recursive: true });

    // Generate main documentation
    await this.generateMainDocumentation(architectureMap, dependencyGraph, componentMap);

    // Generate visual diagrams
    if (this.config.includeVisuals && dependencyGraph) {
      await this.generateVisualDiagrams(dependencyGraph);
    }

    // Generate detailed analysis reports
    if (this.config.includeDetailedAnalysis) {
      await this.generateDetailedReports(architectureMap, componentMap);
    }

    // Export raw data
    await this.exportRawData(architectureMap, dependencyGraph, componentMap);

    console.log(`✅ Documentation generated in ${this.config.outputDir}/`);
  }

  /**
   * Generate main architecture documentation
   */
  private async generateMainDocumentation(
    architectureMap: ArchitectureMap,
    dependencyGraph?: DependencyGraph,
    componentMap?: ComponentMap
  ): Promise<void> {
    const content = this.generateMarkdownContent(architectureMap, dependencyGraph, componentMap);
    const outputPath = path.join(this.config.outputDir, 'architecture-overview.md');
    
    await fs.writeFile(outputPath, content);
    console.log(`📄 Main documentation: ${outputPath}`);
  }

  /**
   * Generate markdown content for architecture overview
   */
  private generateMarkdownContent(
    architectureMap: ArchitectureMap,
    dependencyGraph?: DependencyGraph,
    componentMap?: ComponentMap
  ): string {
    const timestamp = new Date().toISOString().split('T')[0];
    
    return `# System Architecture Overview

**Generated:** ${timestamp}  
**Total Components:** ${architectureMap.totalComponents}  
**Analysis Timestamp:** ${architectureMap.scanTimestamp}

## 📊 Executive Summary

${this.generateExecutiveSummary(architectureMap)}

## 🏗️ Component Distribution

${this.generateComponentDistribution(architectureMap)}

## ⚠️ Risk Assessment

${this.generateRiskAssessment(architectureMap)}

## 🧹 Cleanup Recommendations

${this.generateCleanupRecommendations(architectureMap)}

${dependencyGraph ? this.generateDependencyAnalysis(dependencyGraph) : ''}

${componentMap ? this.generateComponentAnalysis(componentMap) : ''}

## 📈 Test Coverage Analysis

${this.generateTestCoverageAnalysis(architectureMap)}

## 🎯 Next Steps

${this.generateNextSteps(architectureMap)}

---

*This documentation was automatically generated by the Architecture Scanner System.*
*For detailed component information, see the accompanying JSON reports.*
`;
  }

  /**
   * Generate executive summary
   */
  private generateExecutiveSummary(architectureMap: ArchitectureMap): string {
    const { componentsByOrigin, cleanupPriority, testCoverage } = architectureMap;
    const legacyComponents = componentsByOrigin.supabase + componentsByOrigin.lovable;
    const legacyPercentage = Math.round((legacyComponents / architectureMap.totalComponents) * 100);

    return `
The system contains **${architectureMap.totalComponents} components** with the following key characteristics:

- **${componentsByOrigin.kiro} Kiro components** (${Math.round((componentsByOrigin.kiro / architectureMap.totalComponents) * 100)}%) - Modern, well-architected
- **${legacyComponents} Legacy components** (${legacyPercentage}%) - Requiring migration or cleanup
- **${cleanupPriority.length} cleanup candidates** identified for potential archiving
- **${testCoverage.coveragePercentage}% test coverage** - Significant improvement opportunity

### Key Findings

- **Legacy Footprint:** ${legacyPercentage}% of components are legacy (Supabase/Lovable)
- **Cleanup Potential:** ${Math.round((cleanupPriority.length / architectureMap.totalComponents) * 100)}% of components are candidates for cleanup
- **Test Coverage Gap:** Only ${testCoverage.coveragePercentage}% of components have test coverage
- **Risk Distribution:** Detailed risk analysis available in component reports
`;
  }

  /**
   * Generate component distribution analysis
   */
  private generateComponentDistribution(architectureMap: ArchitectureMap): string {
    const { componentsByOrigin } = architectureMap;
    const total = architectureMap.totalComponents;

    return `
| Origin | Count | Percentage | Status |
|--------|-------|------------|--------|
| 🟢 Kiro | ${componentsByOrigin.kiro} | ${Math.round((componentsByOrigin.kiro / total) * 100)}% | Modern, keep |
| 🟡 Supabase | ${componentsByOrigin.supabase} | ${Math.round((componentsByOrigin.supabase / total) * 100)}% | Legacy, migrate |
| 🔴 Lovable | ${componentsByOrigin.lovable} | ${Math.round((componentsByOrigin.lovable / total) * 100)}% | Legacy, migrate |
| ⚫ Unknown | ${componentsByOrigin.unknown} | ${Math.round((componentsByOrigin.unknown / total) * 100)}% | Needs classification |

### Origin Analysis

- **Kiro Components:** Modern components following current architecture patterns
- **Supabase Components:** Legacy components from previous architecture, candidates for migration
- **Lovable Components:** Legacy components from early development phase
- **Unknown Components:** Components requiring manual classification and review
`;
  }

  /**
   * Generate risk assessment section
   */
  private generateRiskAssessment(architectureMap: ArchitectureMap): string {
    const highPriorityItems = architectureMap.cleanupPriority.filter(item => item.priority >= 10);
    const mediumPriorityItems = architectureMap.cleanupPriority.filter(item => item.priority >= 5 && item.priority < 10);
    const lowPriorityItems = architectureMap.cleanupPriority.filter(item => item.priority < 5);

    return `
### Priority Distribution

- **🔴 High Priority:** ${highPriorityItems.length} components (Priority ≥ 10)
- **🟡 Medium Priority:** ${mediumPriorityItems.length} components (Priority 5-9)
- **🟢 Low Priority:** ${lowPriorityItems.length} components (Priority < 5)

### Top Risk Components

${architectureMap.cleanupPriority.slice(0, 10).map((item, index) => 
  `${index + 1}. **${path.basename(item.component)}** (Priority: ${item.priority})
   - Effort: ${item.estimatedEffort}
   - Reason: ${item.reason}`
).join('\n\n')}
`;
  }

  /**
   * Generate cleanup recommendations
   */
  private generateCleanupRecommendations(architectureMap: ArchitectureMap): string {
    const roadmap = this.generateCleanupRoadmap(architectureMap);

    return `
### Cleanup Roadmap

**Total Estimated Effort:** ${roadmap.estimatedHours} hours

#### Phase 1: Quick Wins (${roadmap.phase1.length} items)
Low-effort, high-impact cleanup tasks that can be completed immediately.

${roadmap.phase1.slice(0, 5).map(item => 
  `- ${path.basename(item.component)} (${item.estimatedEffort} effort)`
).join('\n')}

#### Phase 2: Medium Effort (${roadmap.phase2.length} items)
Components requiring moderate refactoring or migration effort.

${roadmap.phase2.slice(0, 5).map(item => 
  `- ${path.basename(item.component)} (${item.estimatedEffort} effort)`
).join('\n')}

#### Phase 3: Complex Tasks (${roadmap.phase3.length} items)
High-risk or complex components requiring careful planning and execution.

${roadmap.phase3.slice(0, 5).map(item => 
  `- ${path.basename(item.component)} (${item.estimatedEffort} effort)`
).join('\n')}
`;
  }

  /**
   * Generate dependency analysis section
   */
  private generateDependencyAnalysis(dependencyGraph: DependencyGraph): string {
    const { metadata } = dependencyGraph;

    return `
## 🕸️ Dependency Analysis

### Graph Statistics

- **Total Nodes:** ${metadata.totalNodes}
- **Total Edges:** ${metadata.totalEdges}
- **Circular Dependencies:** ${metadata.circularDependencies.length}
- **Orphaned Nodes:** ${metadata.orphanedNodes.length}
- **Critical Paths:** ${metadata.criticalPaths.length}

### Circular Dependencies

${metadata.circularDependencies.length > 0 ? 
  metadata.circularDependencies.slice(0, 5).map((cycle, index) => 
    `${index + 1}. ${cycle.join(' → ')}`
  ).join('\n') : 
  'No circular dependencies detected ✅'
}

### Orphaned Components

${metadata.orphanedNodes.length > 0 ?
  metadata.orphanedNodes.slice(0, 10).map(node => `- ${node}`).join('\n') :
  'No orphaned components found ✅'
}
`;
  }

  /**
   * Generate component analysis section
   */
  private generateComponentAnalysis(componentMap: ComponentMap): string {
    const components = Object.values(componentMap);
    const riskDistribution = this.calculateRiskDistribution(components);
    const typeDistribution = this.calculateTypeDistribution(components);

    return `
## 🧩 Component Analysis

### Risk Distribution

${Object.entries(riskDistribution).map(([risk, count]) => {
  const emoji = risk === 'critical' ? '🔴' : risk === 'high' ? '🟠' : risk === 'medium' ? '🟡' : '🟢';
  return `- ${emoji} **${risk.charAt(0).toUpperCase() + risk.slice(1)}:** ${count} components`;
}).join('\n')}

### Type Distribution

${Object.entries(typeDistribution).map(([type, count]) => 
  `- **${type}:** ${count} components`
).join('\n')}

### Archive Candidates

${components.filter(c => c.archiveCandidate).length} components identified as archive candidates:

${components.filter(c => c.archiveCandidate).slice(0, 10).map(component => 
  `- **${component.path}** (${component.riskLevel} risk, ${component.usage})`
).join('\n')}
`;
  }

  /**
   * Generate test coverage analysis
   */
  private generateTestCoverageAnalysis(architectureMap: ArchitectureMap): string {
    const { testCoverage } = architectureMap;

    return `
### Current Coverage

- **Overall Coverage:** ${testCoverage.coveragePercentage}%
- **Tested Components:** ${testCoverage.testedComponents}
- **Untested Components:** ${testCoverage.untestedComponents}

### Coverage by Origin

${testCoverage.coverageByOrigin ? 
  Object.entries(testCoverage.coverageByOrigin).map(([origin, coverage]) => 
    `- **${origin}:** ${coverage}%`
  ).join('\n') : 
  'Detailed coverage by origin not available'
}

### Recommendations

1. **Prioritize testing for high-risk components** - Focus on Supabase legacy components
2. **Implement testing for critical paths** - Ensure core functionality is covered
3. **Add integration tests** - Test component interactions and dependencies
4. **Automate test coverage reporting** - Track progress over time
`;
  }

  /**
   * Generate next steps section
   */
  private generateNextSteps(architectureMap: ArchitectureMap): string {
    return `
### Immediate Actions (Next 2 weeks)

1. **Review cleanup candidates** - Validate the top 10 priority items for safe removal
2. **Address circular dependencies** - Break dependency cycles to improve maintainability
3. **Implement missing tests** - Focus on high-risk, untested components
4. **Document Kiro alternatives** - Ensure migration paths are clear for legacy components

### Medium-term Goals (Next 2 months)

1. **Execute Phase 1 cleanup** - Remove or archive low-risk, unused components
2. **Migrate high-priority Supabase components** - Replace with Kiro alternatives
3. **Improve test coverage** - Target 50% coverage for critical components
4. **Establish monitoring** - Set up automated architecture health checks

### Long-term Vision (Next 6 months)

1. **Complete legacy migration** - Achieve <10% legacy component ratio
2. **Establish architecture governance** - Prevent future technical debt accumulation
3. **Implement automated cleanup** - Set up continuous architecture optimization
4. **Document best practices** - Create guidelines for future development
`;
  }

  /**
   * Generate visual diagrams
   */
  private async generateVisualDiagrams(dependencyGraph: DependencyGraph): Promise<void> {
    const basePath = path.join(this.config.outputDir, 'architecture-graph');

    if (this.config.generateVariants) {
      await generateMermaidVariants(dependencyGraph, basePath);
    } else {
      await generateMermaidDiagram(dependencyGraph, `${basePath}.mmd`);
    }
  }

  /**
   * Generate detailed analysis reports
   */
  private async generateDetailedReports(
    architectureMap: ArchitectureMap,
    componentMap?: ComponentMap
  ): Promise<void> {
    // Component details report
    if (componentMap) {
      const componentReport = this.generateComponentDetailsReport(componentMap);
      await fs.writeFile(
        path.join(this.config.outputDir, 'component-details.md'),
        componentReport
      );
    }

    // Risk analysis report
    const riskReport = this.generateRiskAnalysisReport(architectureMap);
    await fs.writeFile(
      path.join(this.config.outputDir, 'risk-analysis.md'),
      riskReport
    );
  }

  /**
   * Export raw data files
   */
  private async exportRawData(
    architectureMap: ArchitectureMap,
    dependencyGraph?: DependencyGraph,
    componentMap?: ComponentMap
  ): Promise<void> {
    // Export architecture map
    await fs.writeFile(
      path.join(this.config.outputDir, 'architecture-report.json'),
      JSON.stringify(architectureMap, null, 2)
    );

    // Export dependency graph
    if (dependencyGraph) {
      await fs.writeFile(
        path.join(this.config.outputDir, 'dependency-graph.json'),
        JSON.stringify(dependencyGraph, null, 2)
      );
    }

    // Export component map
    if (componentMap) {
      await fs.writeFile(
        path.join(this.config.outputDir, 'component-map.json'),
        JSON.stringify(componentMap, null, 2)
      );
    }
  }

  /**
   * Helper methods
   */
  private generateCleanupRoadmap(architectureMap: ArchitectureMap) {
    const { cleanupPriority } = architectureMap;
    
    const phase1 = cleanupPriority.filter(item => 
      item.priority >= 15 && item.estimatedEffort === 'low'
    );
    
    const phase2 = cleanupPriority.filter(item => 
      item.priority >= 10 && item.estimatedEffort === 'medium'
    );
    
    const phase3 = cleanupPriority.filter(item => 
      !phase1.includes(item) && !phase2.includes(item)
    );

    const effortHours = { low: 0.5, medium: 2, high: 8 };
    const estimatedHours = cleanupPriority.reduce((total, item) => 
      total + effortHours[item.estimatedEffort], 0
    );

    return { phase1, phase2, phase3, estimatedHours };
  }

  private calculateRiskDistribution(components: any[]): Record<string, number> {
    const distribution = { low: 0, medium: 0, high: 0, critical: 0 };
    components.forEach(component => {
      distribution[component.riskLevel]++;
    });
    return distribution;
  }

  private calculateTypeDistribution(components: any[]): Record<string, number> {
    const distribution: Record<string, number> = {};
    components.forEach(component => {
      distribution[component.type] = (distribution[component.type] || 0) + 1;
    });
    return distribution;
  }

  private generateComponentDetailsReport(componentMap: ComponentMap): string {
    // Implementation for detailed component report
    return '# Component Details Report\n\n(Implementation details...)';
  }

  private generateRiskAnalysisReport(architectureMap: ArchitectureMap): string {
    // Implementation for risk analysis report
    return '# Risk Analysis Report\n\n(Implementation details...)';
  }
}

/**
 * Generate complete architecture documentation
 */
export async function generateArchitectureDocumentation(
  architectureMap: ArchitectureMap,
  dependencyGraph?: DependencyGraph,
  componentMap?: ComponentMap,
  config?: Partial<DocumentationConfig>
): Promise<void> {
  const generator = new DocumentationGenerator(config);
  await generator.generateDocumentation(architectureMap, dependencyGraph, componentMap);
}