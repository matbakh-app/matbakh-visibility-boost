/**
 * Test Templates for Code Generation
 * 
 * Provides templates for generating comprehensive test suites
 */

import { CodeGenerationConfig } from '../types';

export class TestTemplates {
    constructor(private config: CodeGenerationConfig) { }

    /**
     * Generate a complete test suite
     */
    generateTestSuite(options: {
        componentName: string;
        testCases: string[];
        setup?: string;
        imports: string[];
    }): string {
        const { componentName, testCases, setup, imports } = options;

        return `/**
 * ${componentName} Component Tests
 * Generated by Kiro Code Generator
 */

${imports.join('\n')}
${setup || ''}

describe('${componentName}', () => {
  beforeEach(() => {
    // Reset any mocks or state before each test
  });

  afterEach(() => {
    // Cleanup after each test
  });

${testCases.join('\n\n')}
});
`;
    }

    /**
     * Generate unit test template
     */
    generateUnitTest(options: {
        name: string;
        description: string;
        setup?: string;
        assertions: string[];
    }): string {
        const { name, description, setup, assertions } = options;

        return `
  it('${description}', ${setup ? 'async ' : ''}() => {
    ${setup || ''}
    
    ${assertions.join('\n    ')}
  });`;
    }

    /**
     * Generate integration test template
     */
    generateIntegrationTest(options: {
        name: string;
        description: string;
        setup: string;
        interactions: string[];
        assertions: string[];
    }): string {
        const { name, description, setup, interactions, assertions } = options;

        return `
  it('${description}', async () => {
    const user = userEvent.setup();
    ${setup}
    
    // User interactions
    ${interactions.join('\n    ')}
    
    // Assertions
    ${assertions.join('\n    ')}
  });`;
    }

    /**
     * Generate accessibility test template
     */
    generateAccessibilityTest(componentName: string): string {
        return `
  it('meets accessibility requirements', async () => {
    const { container } = render(<${componentName} />);
    const results = await axe(container);
    expect(results).toHaveNoViolations();
  });

  it('supports keyboard navigation', async () => {
    const user = userEvent.setup();
    render(<${componentName} />);
    
    // Test keyboard navigation
    await user.tab();
    expect(document.activeElement).toBeInTheDocument();
  });

  it('has proper ARIA attributes', () => {
    render(<${componentName} />);
    const element = screen.getByRole('region');
    
    expect(element).toHaveAttribute('aria-labelledby');
    expect(element).toHaveAttribute('role', 'region');
  });`;
    }

    /**
     * Generate performance test template
     */
    generatePerformanceTest(componentName: string): string {
        return `
  it('renders within performance budget', () => {
    const startTime = performance.now();
    render(<${componentName} />);
    const endTime = performance.now();
    
    // Should render within 16ms (60fps)
    expect(endTime - startTime).toBeLessThan(16);
  });

  it('handles large datasets efficiently', () => {
    const largeDataset = Array.from({ length: 1000 }, (_, i) => ({ id: i, name: \`Item \${i}\` }));
    
    const startTime = performance.now();
    render(<${componentName} data={largeDataset} />);
    const endTime = performance.now();
    
    // Should handle large datasets within reasonable time
    expect(endTime - startTime).toBeLessThan(100);
  });`;
    }

    /**
     * Generate error boundary test template
     */
    generateErrorBoundaryTest(componentName: string): string {
        return `
  it('handles errors gracefully', () => {
    const ThrowError = () => {
      throw new Error('Test error');
    };

    const consoleSpy = jest.spyOn(console, 'error').mockImplementation(() => {});
    
    render(
      <ErrorBoundary>
        <${componentName}>
          <ThrowError />
        </${componentName}>
      </ErrorBoundary>
    );

    expect(screen.getByText(/something went wrong/i)).toBeInTheDocument();
    consoleSpy.mockRestore();
  });`;
    }

    /**
     * Generate snapshot test template
     */
    generateSnapshotTest(componentName: string): string {
        return `
  it('matches snapshot', () => {
    const { container } = render(<${componentName} />);
    expect(container.firstChild).toMatchSnapshot();
  });

  it('matches snapshot with props', () => {
    const props = { className: 'test-class', children: 'Test content' };
    const { container } = render(<${componentName} {...props} />);
    expect(container.firstChild).toMatchSnapshot();
  });`;
    }
}