/**
 * Kiro-compliant Component Generator
 * 
 * Generates React components following Kiro architecture patterns and best practices:
 * - TypeScript strict mode compliance
 * - shadcn/ui component patterns
 * - Tailwind CSS styling
 * - Accessibility compliance (WCAG 2.1 AA)
 * - i18n support
 * - Comprehensive testing
 */

import { ComponentTemplates } from './templates/component-templates';
import { DocumentationTemplates } from './templates/documentation-templates';
import { StoryTemplates } from './templates/story-templates';
import { TestTemplates } from './templates/test-templates';
import { CodeGenerationConfig, ComponentSpec, GeneratedComponent } from './types';

export class ComponentGenerator {
    private templates: ComponentTemplates;
    private testTemplates: TestTemplates;
    private storyTemplates: StoryTemplates;
    private docTemplates: DocumentationTemplates;

    constructor(private config: CodeGenerationConfig) {
        this.templates = new ComponentTemplates(config);
        this.testTemplates = new TestTemplates(config);
        this.storyTemplates = new StoryTemplates(config);
        this.docTemplates = new DocumentationTemplates(config);
    }

    /**
     * Generate a complete component with all associated files
     */
    async generateComponent(spec: ComponentSpec): Promise<GeneratedComponent> {
        const componentName = this.formatComponentName(spec.name);
        const componentPath = this.getComponentPath(spec);

        // Generate main component file
        const componentContent = await this.generateComponentContent(spec);

        // Generate associated files
        const tests = spec.tests ? await this.generateTests(spec) : undefined;
        const stories = spec.storybook ? await this.generateStories(spec) : undefined;
        const documentation = spec.documentation ? await this.generateDocumentation(spec) : undefined;
        const types = await this.generateTypes(spec);

        return {
            name: componentName,
            path: componentPath,
            content: componentContent,
            tests,
            stories,
            documentation,
            types
        };
    }

    /**
     * Generate the main component content
     */
    private async generateComponentContent(spec: ComponentSpec): Promise<string> {
        const template = this.getComponentTemplate(spec.type);

        const templateData = {
            componentName: this.formatComponentName(spec.name),
            props: this.generatePropsInterface(spec),
            imports: this.generateImports(spec),
            content: this.generateComponentBody(spec),
            exports: this.generateExports(spec),
            styling: this.generateStyling(spec),
            accessibility: this.generateAccessibilityFeatures(spec),
            i18n: this.generateI18nSupport(spec)
        };

        return this.templates.render(template, templateData);
    }

    /**
     * Generate component tests
     */
    private async generateTests(spec: ComponentSpec): Promise<string> {
        const testCases = [
            this.generateRenderTest(spec),
            this.generatePropsTest(spec),
            this.generateInteractionTest(spec),
            this.generateAccessibilityTest(spec),
            this.generateI18nTest(spec)
        ].filter(Boolean);

        return this.testTemplates.generateTestSuite({
            componentName: spec.name,
            testCases,
            setup: this.generateTestSetup(spec),
            imports: this.generateTestImports(spec)
        });
    }

    /**
     * Generate Storybook stories
     */
    private async generateStories(spec: ComponentSpec): Promise<string> {
        const stories = [
            this.generateDefaultStory(spec),
            this.generateVariantStories(spec),
            this.generateInteractiveStories(spec)
        ].filter(Boolean);

        return this.storyTemplates.generateStories({
            componentName: spec.name,
            stories,
            controls: this.generateStorybookControls(spec)
        });
    }

    /**
     * Generate component documentation
     */
    private async generateDocumentation(spec: ComponentSpec): Promise<string> {
        return this.docTemplates.generateComponentDocs({
            name: spec.name,
            description: `${spec.name} component following Kiro architecture patterns`,
            props: this.extractPropsDocumentation(spec),
            examples: this.generateUsageExamples(spec),
            accessibility: this.generateAccessibilityDocs(spec),
            styling: this.generateStylingDocs(spec)
        });
    }

    /**
     * Generate TypeScript types
     */
    private async generateTypes(spec: ComponentSpec): Promise<string> {
        return `
/**
 * ${spec.name} Component Types
 * Generated by Kiro Code Generator
 */

import { ReactNode, HTMLAttributes } from 'react';

export interface ${this.formatComponentName(spec.name)}Props extends HTMLAttributes<HTMLDivElement> {
  ${this.generatePropsInterface(spec)}
}

${this.generateAdditionalTypes(spec)}
`;
    }

    // Helper methods
    private formatComponentName(name: string): string {
        return name.charAt(0).toUpperCase() + name.slice(1).replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
    }

    private getComponentPath(spec: ComponentSpec): string {
        const basePath = spec.type === 'ui' ? 'src/components/ui' : `src/components/${spec.type}`;
        return `${basePath}/${spec.name}.tsx`;
    }

    private getComponentTemplate(type: string): string {
        switch (type) {
            case 'ui':
                return 'ui-component';
            case 'feature':
                return 'feature-component';
            case 'page':
                return 'page-component';
            case 'layout':
                return 'layout-component';
            default:
                return 'basic-component';
        }
    }

    private generatePropsInterface(spec: ComponentSpec): string {
        if (!spec.props) return '';

        return Object.entries(spec.props)
            .map(([name, type]) => `  ${name}: ${type};`)
            .join('\n');
    }

    private generateImports(spec: ComponentSpec): string[] {
        const imports = [
            "import * as React from 'react';",
            "import { cn } from '@/lib/utils';"
        ];

        if (spec.i18n) {
            imports.push("import { useTranslation } from 'react-i18next';");
        }

        if (spec.accessibility) {
            imports.push("import { useId } from 'react';");
        }

        return imports;
    }

    private generateComponentBody(spec: ComponentSpec): string {
        const hooks = [];

        if (spec.i18n) {
            hooks.push("const { t } = useTranslation();");
        }

        if (spec.accessibility) {
            hooks.push("const id = useId();");
        }

        const hooksCode = hooks.length > 0 ? hooks.join('\n  ') + '\n\n  ' : '';

        return `
  ${hooksCode}return (
    <div className={cn("${this.generateDefaultClasses(spec)}", className)} {...props}>
      {children}
    </div>
  );`;
    }

    private generateDefaultClasses(spec: ComponentSpec): string {
        switch (spec.type) {
            case 'ui':
                return 'inline-flex items-center justify-center';
            case 'layout':
                return 'w-full h-full';
            case 'page':
                return 'container mx-auto px-4 py-8';
            default:
                return 'block';
        }
    }

    private generateExports(spec: ComponentSpec): string {
        const componentName = this.formatComponentName(spec.name);
        return `export { ${componentName} };`;
    }

    private generateStyling(spec: ComponentSpec): string {
        // Generate Tailwind CSS classes based on component type and spec
        return '';
    }

    private generateAccessibilityFeatures(spec: ComponentSpec): string {
        if (!spec.accessibility) return '';

        return `
  // Accessibility features
  role="region"
  aria-labelledby={id}
  tabIndex={0}`;
    }

    private generateI18nSupport(spec: ComponentSpec): string {
        if (!spec.i18n) return '';

        return `
  // i18n support
  {t('${spec.name.toLowerCase()}.title')}`;
    }

    private generateRenderTest(spec: ComponentSpec): string {
        return `
    it('renders without crashing', () => {
      render(<${this.formatComponentName(spec.name)} />);
      expect(screen.getByRole('region')).toBeInTheDocument();
    });`;
    }

    private generatePropsTest(spec: ComponentSpec): string {
        if (!spec.props) return '';

        return `
    it('handles props correctly', () => {
      const testProps = { className: 'test-class' };
      render(<${this.formatComponentName(spec.name)} {...testProps} />);
      expect(screen.getByRole('region')).toHaveClass('test-class');
    });`;
    }

    private generateInteractionTest(spec: ComponentSpec): string {
        return `
    it('handles user interactions', async () => {
      const user = userEvent.setup();
      render(<${this.formatComponentName(spec.name)} />);
      
      // Add interaction tests based on component type
      const element = screen.getByRole('region');
      await user.click(element);
      
      // Assert expected behavior
    });`;
    }

    private generateAccessibilityTest(spec: ComponentSpec): string {
        if (!spec.accessibility) return '';

        return `
    it('meets accessibility requirements', async () => {
      const { container } = render(<${this.formatComponentName(spec.name)} />);
      const results = await axe(container);
      expect(results).toHaveNoViolations();
    });`;
    }

    private generateI18nTest(spec: ComponentSpec): string {
        if (!spec.i18n) return '';

        return `
    it('supports internationalization', () => {
      render(<${this.formatComponentName(spec.name)} />);
      expect(screen.getByText(/test translation/i)).toBeInTheDocument();
    });`;
    }

    private generateTestSetup(spec: ComponentSpec): string {
        const setup = [];

        if (spec.i18n) {
            setup.push("import '../../../i18n';");
        }

        if (spec.accessibility) {
            setup.push("import { axe, toHaveNoViolations } from 'jest-axe';");
            setup.push("expect.extend(toHaveNoViolations);");
        }

        return setup.join('\n');
    }

    private generateTestImports(spec: ComponentSpec): string[] {
        const imports = [
            "import { render, screen } from '@testing-library/react';",
            "import userEvent from '@testing-library/user-event';",
            `import { ${this.formatComponentName(spec.name)} } from '../${spec.name}';`
        ];

        return imports;
    }

    private generateDefaultStory(spec: ComponentSpec): string {
        return `
export const Default: Story = {
  args: {
    children: 'Default ${spec.name}',
  },
};`;
    }

    private generateVariantStories(spec: ComponentSpec): string {
        // Generate stories for different variants/states
        return '';
    }

    private generateInteractiveStories(spec: ComponentSpec): string {
        // Generate interactive stories with controls
        return '';
    }

    private generateStorybookControls(spec: ComponentSpec): string {
        if (!spec.props) return '';

        return Object.keys(spec.props)
            .map(prop => `    ${prop}: { control: 'text' }`)
            .join(',\n');
    }

    private extractPropsDocumentation(spec: ComponentSpec): Array<{ name: string, type: string, description: string }> {
        if (!spec.props) return [];

        return Object.entries(spec.props).map(([name, type]) => ({
            name,
            type,
            description: `${name} prop for ${spec.name} component`
        }));
    }

    private generateUsageExamples(spec: ComponentSpec): string[] {
        const componentName = this.formatComponentName(spec.name);
        return [
            `<${componentName}>Basic usage</${componentName}>`,
            `<${componentName} className="custom-class">With custom styling</${componentName}>`
        ];
    }

    private generateAccessibilityDocs(spec: ComponentSpec): string {
        if (!spec.accessibility) return '';

        return `
## Accessibility

This component follows WCAG 2.1 AA guidelines:
- Proper ARIA labels and roles
- Keyboard navigation support
- Screen reader compatibility
- Focus management
`;
    }

    private generateStylingDocs(spec: ComponentSpec): string {
        return `
## Styling

This component uses Tailwind CSS for styling and follows the design system patterns:
- Responsive design
- Dark mode support
- Consistent spacing and typography
- Customizable via className prop
`;
    }

    private generateAdditionalTypes(spec: ComponentSpec): string {
        // Generate additional TypeScript types based on component complexity
        return '';
    }
}