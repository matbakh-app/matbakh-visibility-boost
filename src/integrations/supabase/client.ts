
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://uheksobnyedarrpgxhju.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVoZWtzb2JueWVkYXJycGd4aGp1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTAzMDk0NDUsImV4cCI6MjA2NTg4NTQ0NX0.dlbs4P3ZgXByNj7H1_k99YcOok9WmqgLZ1NtjONJYVs";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: localStorage,
    persistSession: true,
    autoRefreshToken: true,
  },
  realtime: {
    params: {
      eventsPerSecond: 10,
    },
    heartbeatIntervalMs: 30000, // 30 seconds heartbeat
    reconnectAfterMs: (tries: number) => {
      // Progressive backoff: 1s, 2s, 4s, 8s, then max 30s
      const delay = Math.min(1000 * Math.pow(2, tries), 30000);
      return delay;
    },
  },
  global: {
    headers: {
      'x-client-info': 'matbakh-app',
    },
  },
});

// Enhanced WebSocket connection management
class RealtimeConnectionManager {
  private static instance: RealtimeConnectionManager;
  private activeChannels: Map<string, any> = new Map();
  private isTabActive = true;
  private heartbeatInterval: NodeJS.Timeout | null = null;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;

  private constructor() {
    this.setupVisibilityHandlers();
  }

  static getInstance(): RealtimeConnectionManager {
    if (!RealtimeConnectionManager.instance) {
      RealtimeConnectionManager.instance = new RealtimeConnectionManager();
    }
    return RealtimeConnectionManager.instance;
  }

  private setupVisibilityHandlers() {
    if (typeof document !== 'undefined') {
      document.addEventListener('visibilitychange', () => {
        this.isTabActive = !document.hidden;
        if (!this.isTabActive) {
          this.disconnectAllChannels();
        } else {
          this.reconnectChannels();
        }
      });

      // Handle page unload
      window.addEventListener('beforeunload', () => {
        this.disconnectAllChannels();
      });
    }
  }

  createChannel(channelName: string, config?: any) {
    if (!this.isTabActive) {
      console.log('Tab is not active, skipping channel creation');
      return null;
    }

    if (this.activeChannels.has(channelName)) {
      console.log(`Channel ${channelName} already exists`);
      return this.activeChannels.get(channelName);
    }

    const channel = supabase.channel(channelName, config);
    
    // Add error handling
    channel.on('broadcast', { event: 'error' }, (error: any) => {
      console.error(`Channel ${channelName} error:`, error);
      this.handleChannelError(channelName, error);
    });

    channel.on('broadcast', { event: 'close' }, () => {
      console.log(`Channel ${channelName} closed`);
      this.activeChannels.delete(channelName);
    });

    this.activeChannels.set(channelName, channel);
    return channel;
  }

  private handleChannelError(channelName: string, error: any) {
    this.activeChannels.delete(channelName);
    
    if (this.reconnectAttempts < this.maxReconnectAttempts && this.isTabActive) {
      this.reconnectAttempts++;
      const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);
      
      setTimeout(() => {
        console.log(`Attempting to reconnect channel ${channelName}, attempt ${this.reconnectAttempts}`);
        this.createChannel(channelName);
      }, delay);
    } else {
      console.warn(`Max reconnection attempts reached for channel ${channelName}`);
      // Show user notification if needed
      this.showConnectionError();
    }
  }

  private showConnectionError() {
    if (typeof window !== 'undefined' && window.location.pathname.includes('/dashboard')) {
      // Only show error on dashboard pages where realtime is critical
      const event = new CustomEvent('realtime-connection-error', {
        detail: { message: 'Verbindung verloren. Bitte laden Sie die Seite neu.' }
      });
      window.dispatchEvent(event);
    }
  }

  disconnectAllChannels() {
    this.activeChannels.forEach((channel, name) => {
      try {
        channel.unsubscribe();
        console.log(`Disconnected channel: ${name}`);
      } catch (error) {
        console.warn(`Error disconnecting channel ${name}:`, error);
      }
    });
    this.activeChannels.clear();
    
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
      this.heartbeatInterval = null;
    }
  }

  private reconnectChannels() {
    // Reset reconnect attempts when tab becomes active again
    this.reconnectAttempts = 0;
    
    // Note: Channel recreation should be handled by the components
    // that originally created them, as they know the specific config
  }

  getActiveChannelCount(): number {
    return this.activeChannels.size;
  }
}

export const realtimeManager = RealtimeConnectionManager.getInstance();
