/**
 * Architecture Scanner Tests
 * Test suite for the architecture scanning engine
 */

import { describe, it, expect, beforeEach, jest } from '@jest/globals';
import { ArchitectureScanner } from '@/lib/architecture-scanner/architecture-scanner';
import { OriginDetector } from '@/lib/architecture-scanner/origin-detector';
import { UsageAnalyzer } from '@/lib/architecture-scanner/usage-analyzer';
import { FileSystemCrawler } from '@/lib/architecture-scanner/file-system-crawler';

// Mock file system operations
jest.mock('fs/promises');

describe('ArchitectureScanner', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('Origin Detection', () => {
    it('should detect Kiro components correctly', () => {
      const content = `
        // @kiro Generated by Kiro AI
        import { BedrockClient } from '@aws-sdk/client-bedrock';
        export const KiroComponent = () => {};
      `;
      
      const result = OriginDetector.detectOrigin('src/components/KiroComponent.tsx', content);
      
      expect(result.origin).toBe('kiro');
      expect(result.confidence).toBeGreaterThan(0.8);
    });

    it('should detect Supabase components correctly', () => {
      const content = `
        import { createClient } from '@supabase/supabase-js';
        const supabase = createClient(url, key);
      `;
      
      const result = OriginDetector.detectOrigin('src/services/supabase-client.ts', content);
      
      expect(result.origin).toBe('supabase');
      expect(result.confidence).toBeGreaterThan(0.7);
    });

    it('should detect Lovable components correctly', () => {
      const content = `
        /** @lovable Component generated by Lovable */
        export const LovableComponent = () => {};
      `;
      
      const result = OriginDetector.detectOrigin('src/components/LovableComponent.tsx', content);
      
      expect(result.origin).toBe('lovable');
      expect(result.confidence).toBeGreaterThan(0.8);
    });

    it('should return unknown for unidentifiable components', () => {
      const content = `
        export const GenericComponent = () => {
          return <div>Hello World</div>;
        };
      `;
      
      const result = OriginDetector.detectOrigin('src/components/GenericComponent.tsx', content);
      
      expect(result.origin).toBe('unknown');
      expect(result.confidence).toBe(0);
    });
  });

  describe('Usage Analysis', () => {
    it('should analyze imports correctly', () => {
      const content = `
        import React from 'react';
        import { Button } from '@/components/ui/button';
        import { useAuth } from '../hooks/useAuth';
        const Component = require('./Component');
      `;
      
      const imports = UsageAnalyzer.analyzeImports(content);
      
      expect(imports).toContain('src/components/ui/button');
      expect(imports).toContain('../hooks/useAuth');
      expect(imports).toContain('./Component');
      expect(imports).not.toContain('react'); // External module
    });

    it('should analyze exports correctly', () => {
      const content = `
        export const Button = () => {};
        export function Dialog() {}
        export default Component;
        export { Modal, Toast } from './ui';
      `;
      
      const exports = UsageAnalyzer.analyzeExports(content);
      
      expect(exports).toContain('Button');
      expect(exports).toContain('Dialog');
      expect(exports).toContain('Modal');
      expect(exports).toContain('Toast');
    });
  });

  describe('Kiro Alternative Detection', () => {
    it('should find Kiro alternatives for known legacy components', () => {
      const alternative = OriginDetector.findKiroAlternative('src/pages/Login.tsx', 'supabase');
      expect(alternative).toBe('src/components/auth/KiroLogin.tsx');
    });

    it('should return undefined for Kiro components', () => {
      const alternative = OriginDetector.findKiroAlternative('src/components/KiroComponent.tsx', 'kiro');
      expect(alternative).toBeUndefined();
    });

    it('should return undefined for unknown legacy components', () => {
      const alternative = OriginDetector.findKiroAlternative('src/components/UnknownComponent.tsx', 'lovable');
      expect(alternative).toBeUndefined();
    });
  });

  describe('Risk Level Calculation', () => {
    it('should assign low risk to Kiro components', () => {
      const mockUsage = {
        importedBy: ['src/App.tsx'],
        circularDependencies: []
      };
      
      // Access private method for testing
      const riskLevel = (ArchitectureScanner as any).calculateRiskLevel(
        'kiro',
        mockUsage,
        'src/components/KiroComponent.tsx',
        0.9
      );
      
      expect(riskLevel).toBe('low');
    });

    it('should assign high risk to heavily used legacy components', () => {
      const mockUsage = {
        importedBy: new Array(6).fill('src/component.tsx'), // Reduced to avoid critical threshold
        circularDependencies: []
      };
      
      const riskLevel = (ArchitectureScanner as any).calculateRiskLevel(
        'supabase',
        mockUsage,
        'src/services/other.ts', // Changed from auth.ts to avoid critical path
        0.9
      );
      
      expect(riskLevel).toBe('high');
    });

    it('should assign critical risk to context providers with circular dependencies', () => {
      const mockUsage = {
        importedBy: new Array(12).fill('src/component.tsx'),
        circularDependencies: ['src/hooks/useAuth.ts', 'src/contexts/AuthContext.tsx']
      };
      
      const riskLevel = (ArchitectureScanner as any).calculateRiskLevel(
        'supabase',
        mockUsage,
        'src/contexts/AuthContext.tsx',
        0.9
      );
      
      expect(riskLevel).toBe('critical');
    });
  });

  describe('Cleanup Priority Generation', () => {
    it('should prioritize components with Kiro alternatives', () => {
      const mockComponentMap = {
        'src/pages/Login.tsx': {
          origin: 'supabase' as const,
          hasKiroAlternative: true,
          isActive: true,
          riskLevel: 'low' as const // Low risk = higher cleanup priority
        },
        'src/components/Button.tsx': {
          origin: 'lovable' as const,
          hasKiroAlternative: false, // No alternative = lower priority
          isActive: true,
          riskLevel: 'medium' as const // Medium risk = no bonus
        }
      };
      
      const priorities = (ArchitectureScanner as any).generateCleanupPriority(mockComponentMap);
      
      // Login should have higher priority: hasKiroAlternative(+10) + low risk(+5) + supabase(+3) = 18
      // Button should have lower priority: no alternative(+0) + medium risk(+0) + lovable(+3) = 3
      const loginPriority = priorities.find(p => p.component === 'src/pages/Login.tsx');
      const buttonPriority = priorities.find(p => p.component === 'src/components/Button.tsx');
      
      expect(loginPriority).toBeDefined();
      expect(buttonPriority).toBeDefined();
      expect(loginPriority!.priority).toBeGreaterThan(buttonPriority!.priority);
    });

    it('should prioritize unused components', () => {
      const mockComponentMap = {
        'src/components/UnusedComponent.tsx': {
          origin: 'lovable' as const,
          hasKiroAlternative: false,
          isActive: false,
          riskLevel: 'low' as const
        },
        'src/components/ActiveComponent.tsx': {
          origin: 'lovable' as const,
          hasKiroAlternative: false,
          isActive: true,
          riskLevel: 'low' as const
        }
      };
      
      const priorities = (ArchitectureScanner as any).generateCleanupPriority(mockComponentMap);
      
      const unusedPriority = priorities.find(p => p.component.includes('UnusedComponent'));
      const activePriority = priorities.find(p => p.component.includes('ActiveComponent'));
      
      expect(unusedPriority?.priority).toBeGreaterThan(activePriority?.priority || 0);
    });
  });

  describe('Roadmap Generation', () => {
    it('should generate cleanup roadmap with phases', () => {
      const mockArchitectureMap = {
        scanTimestamp: new Date().toISOString(),
        totalComponents: 10,
        componentsByOrigin: { kiro: 5, supabase: 3, lovable: 2, unknown: 0 },
        components: {},
        cleanupPriority: [
          { component: 'high-priority.tsx', priority: 20, reason: 'Test', estimatedEffort: 'low' as const },
          { component: 'medium-priority.tsx', priority: 12, reason: 'Test', estimatedEffort: 'medium' as const },
          { component: 'low-priority.tsx', priority: 5, reason: 'Test', estimatedEffort: 'high' as const }
        ],
        testCoverage: {
          totalFiles: 10,
          testedFiles: 8,
          coveragePercentage: 80,
          uncoveredComponents: []
        }
      };
      
      const roadmap = ArchitectureScanner.generateCleanupRoadmap(mockArchitectureMap);
      
      expect(roadmap.phase1).toHaveLength(1);
      expect(roadmap.phase2).toHaveLength(1);
      expect(roadmap.phase3).toHaveLength(1);
      expect(roadmap.summary.totalComponents).toBe(10);
      expect(roadmap.summary.toCleanup).toBe(3);
      expect(roadmap.summary.estimatedHours).toBeGreaterThan(0);
    });
  });
});