#!/bin/bash

# Pre-commit Hook for Legacy Code Pattern Detection
# Prevents commits containing legacy code patterns

set -e

echo "üîç Running Legacy Code Pattern Detection..."

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Configuration
LEGACY_PATTERNS=(
    # Supabase patterns (BLOCK - being migrated to AWS)
    "createClient.*supabase"
    "supabase\.from"
    "supabase\.auth"
    "supabase\.storage"
    "@supabase/supabase-js"
    
    # Lovable patterns (BLOCK - replaced by Kiro)
    "lovable-generated"
    "lovable-ui"
    "lovable-component"
    "// Generated by Lovable"
    
    # Legacy API patterns (BLOCK)
    "api\.lovable"
    "lovable\.api"
    "supabase\.co"
    
    # Legacy imports (BLOCK - except in migration files)
    "from.*supabase"
    "import.*supabase"
    "require.*supabase"
    
    # Legacy file patterns (BLOCK)
    "supabase/"
    "lovable/"
    ".lovable"
    ".supabase"
    
    # Vercel patterns (BLOCK - replaced by AWS)
    "@vercel/"
    "vercel\.json"
    "vercel\.app"
    "VERCEL_"
    "process\.env\.VERCEL"
    "useVercel"
    "VercelProvider"
    "vercel-analytics"
    "@vercel/analytics"
    "@vercel/speed-insights"
    "vercel\.com"
    "vercel-edge"
    "edge-config"
    "@vercel/edge-config"
    "from.*vercel"
    "import.*vercel"
    "require.*vercel"
    ".vercel/"
    "vercel/"
    
    # Legacy environment variables (BLOCK)
    "SUPABASE_"
    "LOVABLE_"
    "VERCEL_"
    "NEXT_PUBLIC_VERCEL"
    
    # Legacy component patterns (BLOCK)
    "SupabaseProvider"
    "LovableComponent"
    "SupabaseAuth"
    "VercelProvider"
    "VercelAnalytics"
    "VercelDeployment"
    
    # Legacy database patterns (BLOCK)
    "supabase_"
    "lovable_"
    "vercel_"
    
    # Vercel patterns (BLOCK - being migrated to AWS)
    "@vercel/"
    "vercel\."
    "vercel "
    "import.*vercel"
    "from.*vercel"
)

# Allowed patterns (ALLOW - for migration and hackathon)
ALLOWED_PATTERNS=(
    # AWS Cognito patterns (ALLOW - migration target)
    "@aws-sdk/client-cognito"
    "CognitoIdentityProvider"
    "aws-amplify"
    "useAuthenticator"
    
    # Kiro patterns (ALLOW - hackathon demo)
    "kiro-matbakh-visibility-coach"
    "/.kiro/"
    ".kiro/"
    "kiro-alternatives"
    
    # Migration patterns (ALLOW - temporary during transition)
    "migration"
    "migrate"
    "cognito-test"
    "auth-test"
    
    # AWS patterns (ALLOW - target architecture)
    "@aws-sdk"
    "aws-lambda"
    "cloudwatch"
    "s3"
    "rds"
    "cloudfront"
    "amplify"
    "api-gateway"
    "lambda-edge"
    "aws-cdk"
    "aws-cli"
    
    # Temporary exceptions (ALLOW - until migration complete)
    "@vercel/speed-insights"  # Analytics - will be replaced by CloudWatch
    ".vercel/"               # Config directory - will be removed
)

# Function to check if pattern is allowed
is_allowed_pattern() {
    local file=$1
    local pattern=$2
    
    # Check if file is in allowed directories (STRICT)
    if [[ "$file" =~ ^\.kiro/ ]] || [[ "$file" =~ migration/ ]] || [[ "$file" =~ test.*cognito ]]; then
        return 0
    fi
    
    # Check if pattern matches AWS patterns (ONLY AWS allowed)
    for allowed in "${ALLOWED_PATTERNS[@]}"; do
        if [[ "$pattern" =~ $allowed ]] && [[ ! "$pattern" =~ supabase ]] && [[ ! "$pattern" =~ lovable ]] && [[ ! "$pattern" =~ vercel ]]; then
            return 0
        fi
    done
    
    return 1
}

# Function to check for legacy patterns in staged files
check_legacy_patterns() {
    local file=$1
    local violations=0
    
    echo -e "${YELLOW}üîç Checking: ${file}${NC}"
    
    for pattern in "${LEGACY_PATTERNS[@]}"; do
        if git show ":$file" | grep -q "$pattern"; then
            # Check if this pattern is allowed for this file
            if is_allowed_pattern "$file" "$pattern"; then
                echo -e "${GREEN}‚úÖ Legacy pattern allowed in ${file}: ${pattern} (migration/kiro)${NC}"
            else
                echo -e "${RED}‚ùå Legacy pattern found in ${file}: ${pattern}${NC}"
                ((violations++))
            fi
        fi
    done
    
    return $violations
}

# Function to check for archived component usage
check_archived_components() {
    local file=$1
    local violations=0
    
    # Check for imports from archived directories
    if git show ":$file" | grep -q "from.*src/archive"; then
        echo -e "${RED}‚ùå Import from archived directory found in ${file}${NC}"
        ((violations++))
    fi
    
    # Check for imports from deprecated directories
    if git show ":$file" | grep -q "from.*src/deprecated"; then
        echo -e "${RED}‚ùå Import from deprecated directory found in ${file}${NC}"
        ((violations++))
    fi
    
    return $violations
}

# Function to check for legacy test patterns
check_legacy_test_patterns() {
    local file=$1
    local violations=0
    
    # Check for legacy test utilities
    if git show ":$file" | grep -q "supabase.*test"; then
        echo -e "${RED}‚ùå Legacy test pattern found in ${file}: supabase test utilities${NC}"
        ((violations++))
    fi
    
    # Check for legacy mock patterns
    if git show ":$file" | grep -q "mock.*supabase"; then
        echo -e "${RED}‚ùå Legacy mock pattern found in ${file}: supabase mocks${NC}"
        ((violations++))
    fi
    
    return $violations
}

# Get staged files
staged_files=$(git diff --cached --name-only --diff-filter=ACM)

if [[ -z "$staged_files" ]]; then
    echo -e "${GREEN}‚úÖ No staged files to check${NC}"
    exit 0
fi

total_violations=0
checked_files=0

# Check each staged file
for file in $staged_files; do
    # Skip binary files and certain file types
    if [[ "$file" =~ \.(jpg|jpeg|png|gif|ico|pdf|zip|tar|gz|bz2|xz|7z|rar|exe|dll|so|dylib|a|o|obj|bin|dat|db|sqlite|sqlite3|lock|log)$ ]]; then
        continue
    fi
    
    # Skip node_modules and other directories
    if [[ "$file" =~ ^(node_modules|dist|build|coverage|\.git)/ ]]; then
        continue
    fi
    
    # Skip if file doesn't exist (deleted files)
    if [[ ! -f "$file" ]]; then
        continue
    fi
    
    ((checked_files++))
    
    # Check for legacy patterns
    if ! check_legacy_patterns "$file"; then
        total_violations=$((total_violations + $?))
    fi
    
    # Check for archived component usage
    if ! check_archived_components "$file"; then
        total_violations=$((total_violations + $?))
    fi
    
    # Check for legacy test patterns in test files
    if [[ "$file" =~ \.(test|spec)\.(ts|tsx|js|jsx)$ ]]; then
        if ! check_legacy_test_patterns "$file"; then
            total_violations=$((total_violations + $?))
        fi
    fi
done

echo -e "\n${YELLOW}üìä Legacy Code Detection Summary:${NC}"
echo -e "${YELLOW}  Files checked: ${checked_files}${NC}"
echo -e "${YELLOW}  Violations found: ${total_violations}${NC}"

if [[ $total_violations -gt 0 ]]; then
    echo -e "\n${RED}‚ùå COMMIT BLOCKED: Legacy code patterns detected!${NC}"
    echo -e "${RED}Please remove legacy code patterns before committing.${NC}"
    echo -e "\n${YELLOW}üí° Suggestions:${NC}"
    echo -e "${YELLOW}  1. Replace Supabase imports with AWS Cognito/RDS alternatives${NC}"
    echo -e "${YELLOW}  2. Replace Vercel imports with AWS CloudFront/Lambda alternatives${NC}"
    echo -e "${YELLOW}  3. Remove references to archived/deprecated components${NC}"
    echo -e "${YELLOW}  4. Update test utilities to use AWS-based mocks${NC}"
    echo -e "${YELLOW}  5. Use kiro-alternatives.json for migration mappings${NC}"
    echo -e "${YELLOW}  6. For hackathon: Kiro patterns are allowed in .kiro/ directory${NC}"
    echo -e "${YELLOW}  7. AWS-only architecture: No Supabase, Lovable, or Vercel${NC}"
    exit 1
else
    echo -e "\n${GREEN}‚úÖ No legacy code patterns detected${NC}"
    echo -e "${GREEN}üéâ Commit approved!${NC}"
    exit 0
fi