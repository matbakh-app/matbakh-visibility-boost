{"file":"/Users/matbakh-visibility-boost.20250920/src/lib/ai-orchestrator/mcp-fallback-reliability-system.ts","mappings":"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","names":[],"sources":["/Users/matbakh-visibility-boost.20250920/src/lib/ai-orchestrator/mcp-fallback-reliability-system.ts"],"sourcesContent":["/**\n * MCP Fallback Reliability System\n *\n * Ensures >99% success rate when direct Bedrock is unavailable by implementing\n * advanced retry mechanisms, circuit breaker patterns, and health monitoring.\n *\n * Key Features:\n * - Advanced retry logic with exponential backoff\n * - Circuit breaker protection\n * - Real-time performance monitoring\n * - Health-based recovery mechanisms\n * - Comprehensive metrics and reporting\n */\n\nimport { AuditTrailSystem } from \"./audit-trail-system\";\nimport { MCPRouter } from \"./mcp-router\";\n\nexport interface MCPFallbackConfig {\n  maxRetries: number;\n  baseRetryDelay: number;\n  maxRetryDelay: number;\n  exponentialBackoffMultiplier: number;\n  circuitBreakerThreshold: number;\n  circuitBreakerTimeout: number;\n  healthCheckInterval: number;\n  successRateTarget: number;\n  performanceThresholds: {\n    maxLatency: number;\n    maxErrorRate: number;\n    minSuccessRate: number;\n  };\n}\n\nexport interface MCPFallbackMetrics {\n  totalFallbackAttempts: number;\n  successfulFallbacks: number;\n  failedFallbacks: number;\n  successRate: number;\n  averageLatency: number;\n  retryCount: number;\n  circuitBreakerTrips: number;\n  lastHealthCheck: Date;\n  performanceGrade: \"A\" | \"B\" | \"C\" | \"D\" | \"F\";\n  recommendations: string[];\n}\n\nexport interface MCPFallbackResult {\n  success: boolean;\n  response?: any;\n  error?: Error;\n  latency: number;\n  retryCount: number;\n  routeUsed: \"mcp\" | \"fallback\";\n  correlationId: string;\n}\n\nexport interface MCPHealthStatus {\n  isHealthy: boolean;\n  lastCheck: Date;\n  consecutiveFailures: number;\n  averageLatency: number;\n  successRate: number;\n  queueSize: number;\n  pendingOperations: number;\n}\n\nexport interface ReliabilityValidation {\n  meetsTarget: boolean;\n  currentSuccessRate: number;\n  targetSuccessRate: number;\n  totalOperations: number;\n  recommendations: string[];\n  lastValidation: Date;\n}\n\nexport interface HealthCheckResult {\n  healthImproved: boolean;\n  previousHealth: MCPHealthStatus;\n  currentHealth: MCPHealthStatus;\n  actions: string[];\n  timestamp: Date;\n}\n\nexport interface ConfigOptimization {\n  optimizations: string[];\n  newConfig: Partial<MCPFallbackConfig>;\n  expectedImprovement: number;\n  riskLevel: \"low\" | \"medium\" | \"high\";\n}\n\nexport class MCPFallbackReliabilitySystem {\n  private mcpRouter: MCPRouter;\n  private auditTrail: AuditTrailSystem;\n  private config: MCPFallbackConfig;\n  private metrics: MCPFallbackMetrics;\n  private healthStatus: MCPHealthStatus;\n  private circuitBreakerOpen: boolean = false;\n  private circuitBreakerOpenTime?: Date;\n  private healthCheckTimer?: NodeJS.Timeout;\n  private operationHistory: Array<{\n    timestamp: Date;\n    success: boolean;\n    latency: number;\n    error?: string;\n  }> = [];\n\n  constructor(\n    mcpRouter: MCPRouter,\n    auditTrail?: AuditTrailSystem,\n    config?: Partial<MCPFallbackConfig>\n  ) {\n    this.mcpRouter = mcpRouter;\n    this.auditTrail = auditTrail || new AuditTrailSystem();\n\n    // Default production configuration optimized for >99% success rate\n    this.config = {\n      maxRetries: 5,\n      baseRetryDelay: 1000, // 1 second\n      maxRetryDelay: 30000, // 30 seconds\n      exponentialBackoffMultiplier: 2,\n      circuitBreakerThreshold: 5,\n      circuitBreakerTimeout: 60000, // 1 minute\n      healthCheckInterval: 30000, // 30 seconds\n      successRateTarget: 0.99, // 99%\n      performanceThresholds: {\n        maxLatency: 15000, // 15 seconds\n        maxErrorRate: 0.01, // 1%\n        minSuccessRate: 0.99, // 99%\n      },\n      ...config,\n    };\n\n    this.initializeMetrics();\n    this.initializeHealthStatus();\n    this.startHealthMonitoring();\n  }\n\n  private initializeMetrics(): void {\n    this.metrics = {\n      totalFallbackAttempts: 0,\n      successfulFallbacks: 0,\n      failedFallbacks: 0,\n      successRate: 1.0,\n      averageLatency: 0,\n      retryCount: 0,\n      circuitBreakerTrips: 0,\n      lastHealthCheck: new Date(),\n      performanceGrade: \"A\",\n      recommendations: [],\n    };\n  }\n\n  private initializeHealthStatus(): void {\n    this.healthStatus = {\n      isHealthy: true,\n      lastCheck: new Date(),\n      consecutiveFailures: 0,\n      averageLatency: 0,\n      successRate: 1.0,\n      queueSize: 0,\n      pendingOperations: 0,\n    };\n  }\n\n  private startHealthMonitoring(): void {\n    this.healthCheckTimer = setInterval(\n      () => this.performHealthCheck(),\n      this.config.healthCheckInterval\n    );\n  }\n\n  /**\n   * Execute MCP fallback operation with reliability guarantees\n   */\n  async executeFallbackOperation(\n    request: any,\n    correlationId: string,\n    reason: string = \"Direct Bedrock unavailable\"\n  ): Promise<MCPFallbackResult> {\n    const startTime = Date.now();\n    let retryCount = 0;\n    let lastError: Error | undefined;\n\n    // Log fallback initiation\n    await this.auditTrail.logEvent({\n      eventType: \"mcp_fallback_initiation\",\n      correlationId,\n      metadata: {\n        reason,\n        config: this.config,\n        healthStatus: this.healthStatus,\n      },\n    });\n\n    // Check circuit breaker\n    if (this.isCircuitBreakerOpen()) {\n      const error = new Error(\"MCP fallback circuit breaker is open\");\n      await this.recordFailure(startTime, error, correlationId);\n      return {\n        success: false,\n        error,\n        latency: Math.max(Date.now() - startTime, 1), // Ensure minimum 1ms latency\n        retryCount: 0,\n        routeUsed: \"fallback\",\n        correlationId,\n      };\n    }\n\n    // Execute with retry logic\n    for (let attempt = 0; attempt <= this.config.maxRetries; attempt++) {\n      try {\n        // Add jitter to prevent thundering herd\n        if (attempt > 0) {\n          const delay = this.calculateRetryDelay(attempt);\n          await this.sleep(delay);\n          retryCount++;\n        }\n\n        // Check health before retry\n        if (attempt > 0 && !this.healthStatus.isHealthy) {\n          await this.performHealthCheck();\n        }\n\n        // Execute MCP operation\n        const response = await this.mcpRouter.routeRequest(request, {\n          timeout: this.config.performanceThresholds.maxLatency,\n          priority: \"high\",\n          correlationId,\n        });\n\n        // Success - record and return\n        const latency = Math.max(Date.now() - startTime, 1); // Ensure minimum 1ms latency\n        await this.recordSuccess(latency, correlationId);\n\n        return {\n          success: true,\n          response,\n          latency,\n          retryCount,\n          routeUsed: \"mcp\",\n          correlationId,\n        };\n      } catch (error) {\n        lastError = error as Error;\n\n        // Check if we should retry\n        if (\n          attempt < this.config.maxRetries &&\n          this.shouldRetry(error as Error)\n        ) {\n          continue;\n        }\n\n        // Final failure\n        break;\n      }\n    }\n\n    // All retries exhausted - record failure\n    const latency = Math.max(Date.now() - startTime, 1); // Ensure minimum 1ms latency\n    await this.recordFailure(latency, lastError!, correlationId);\n\n    return {\n      success: false,\n      error: lastError,\n      latency,\n      retryCount,\n      routeUsed: \"fallback\",\n      correlationId,\n    };\n  }\n\n  private calculateRetryDelay(attempt: number): number {\n    const baseDelay =\n      this.config.baseRetryDelay *\n      Math.pow(this.config.exponentialBackoffMultiplier, attempt - 1);\n\n    // Add jitter (Â±25%)\n    const jitter = baseDelay * 0.25 * (Math.random() - 0.5);\n    const delay = Math.min(baseDelay + jitter, this.config.maxRetryDelay);\n\n    return Math.max(delay, 0);\n  }\n\n  private shouldRetry(error: Error): boolean {\n    // Don't retry on certain error types\n    const nonRetryableErrors = [\n      \"ValidationError\",\n      \"AuthenticationError\",\n      \"AuthorizationError\",\n      \"InvalidInputError\",\n    ];\n\n    // Check both constructor name and error name property\n    return (\n      !nonRetryableErrors.includes(error.constructor.name) &&\n      !nonRetryableErrors.includes(error.name)\n    );\n  }\n\n  private isCircuitBreakerOpen(): boolean {\n    if (!this.circuitBreakerOpen) {\n      return false;\n    }\n\n    // Check if timeout has passed\n    if (this.circuitBreakerOpenTime) {\n      const timeOpen = Date.now() - this.circuitBreakerOpenTime.getTime();\n      if (timeOpen >= this.config.circuitBreakerTimeout) {\n        this.circuitBreakerOpen = false;\n        this.circuitBreakerOpenTime = undefined;\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private async recordSuccess(\n    latency: number,\n    correlationId: string\n  ): Promise<void> {\n    this.metrics.totalFallbackAttempts++;\n    this.metrics.successfulFallbacks++;\n    this.updateMetrics(latency, true);\n\n    // Reset circuit breaker on success\n    if (this.circuitBreakerOpen) {\n      this.circuitBreakerOpen = false;\n      this.circuitBreakerOpenTime = undefined;\n    }\n\n    // Reset consecutive failures\n    this.healthStatus.consecutiveFailures = 0;\n\n    // Record in operation history\n    this.operationHistory.push({\n      timestamp: new Date(),\n      success: true,\n      latency,\n    });\n\n    // Trim history to last 1000 operations\n    if (this.operationHistory.length > 1000) {\n      this.operationHistory = this.operationHistory.slice(-1000);\n    }\n\n    // Log success\n    await this.auditTrail.logEvent({\n      eventType: \"mcp_fallback_completion\",\n      correlationId,\n      metadata: {\n        success: true,\n        latency,\n        metrics: this.metrics,\n      },\n    });\n  }\n\n  private async recordFailure(\n    latency: number,\n    error: Error,\n    correlationId: string\n  ): Promise<void> {\n    this.metrics.totalFallbackAttempts++;\n    this.metrics.failedFallbacks++;\n    this.updateMetrics(latency, false);\n\n    // Update health status\n    this.healthStatus.consecutiveFailures++;\n\n    // Check circuit breaker threshold\n    if (\n      this.healthStatus.consecutiveFailures >=\n      this.config.circuitBreakerThreshold\n    ) {\n      this.circuitBreakerOpen = true;\n      this.circuitBreakerOpenTime = new Date();\n      this.metrics.circuitBreakerTrips++;\n    }\n\n    // Record in operation history\n    this.operationHistory.push({\n      timestamp: new Date(),\n      success: false,\n      latency,\n      error: error.message,\n    });\n\n    // Trim history\n    if (this.operationHistory.length > 1000) {\n      this.operationHistory = this.operationHistory.slice(-1000);\n    }\n\n    // Log failure\n    await this.auditTrail.logEvent({\n      eventType: \"mcp_fallback_completion\",\n      correlationId,\n      metadata: {\n        success: false,\n        error: error.message,\n        latency,\n        metrics: this.metrics,\n      },\n    });\n\n    // Log reliability issue if success rate drops below target\n    if (this.metrics.successRate < this.config.successRateTarget) {\n      await this.auditTrail.logEvent({\n        eventType: \"mcp_fallback_reliability_issue\",\n        correlationId,\n        metadata: {\n          currentSuccessRate: this.metrics.successRate,\n          targetSuccessRate: this.config.successRateTarget,\n          consecutiveFailures: this.healthStatus.consecutiveFailures,\n          recommendations: this.generateRecommendations(),\n        },\n      });\n    }\n  }\n\n  private updateMetrics(latency: number, success: boolean): void {\n    // Update success rate\n    this.metrics.successRate =\n      this.metrics.totalFallbackAttempts > 0\n        ? this.metrics.successfulFallbacks / this.metrics.totalFallbackAttempts\n        : 1.0;\n\n    // Update average latency\n    const totalLatency =\n      this.metrics.averageLatency * (this.metrics.totalFallbackAttempts - 1) +\n      latency;\n    this.metrics.averageLatency =\n      totalLatency / this.metrics.totalFallbackAttempts;\n\n    // Update performance grade\n    this.metrics.performanceGrade = this.calculatePerformanceGrade();\n\n    // Update recommendations\n    this.metrics.recommendations = this.generateRecommendations();\n  }\n\n  private calculatePerformanceGrade(): \"A\" | \"B\" | \"C\" | \"D\" | \"F\" {\n    const successRate = this.metrics.successRate;\n    const avgLatency = this.metrics.averageLatency;\n\n    if (successRate >= 0.99 && avgLatency <= 5000) return \"A\";\n    if (successRate >= 0.98 && avgLatency <= 10000) return \"B\";\n    if (successRate >= 0.95 && avgLatency <= 15000) return \"C\";\n    if (successRate >= 0.9 && avgLatency <= 30000) return \"D\";\n    return \"F\";\n  }\n\n  private generateRecommendations(): string[] {\n    const recommendations: string[] = [];\n\n    if (this.metrics.successRate < this.config.successRateTarget) {\n      recommendations.push(\n        \"Success rate below target - consider increasing retry count or improving MCP health\"\n      );\n    }\n\n    if (\n      this.metrics.averageLatency > this.config.performanceThresholds.maxLatency\n    ) {\n      recommendations.push(\n        \"Average latency too high - consider optimizing MCP operations or reducing timeout\"\n      );\n    }\n\n    if (this.metrics.circuitBreakerTrips > 0) {\n      recommendations.push(\n        \"Circuit breaker has tripped - investigate MCP connectivity issues\"\n      );\n    }\n\n    if (this.healthStatus.consecutiveFailures > 2) {\n      recommendations.push(\n        \"Multiple consecutive failures detected - perform health check and recovery\"\n      );\n    }\n\n    if (recommendations.length === 0) {\n      recommendations.push(\"System performing within acceptable parameters\");\n    }\n\n    return recommendations;\n  }\n\n  private async performHealthCheck(): Promise<void> {\n    try {\n      // Check MCP router health\n      const mcpHealth = await this.mcpRouter.getHealthStatus();\n\n      // Update health status\n      this.healthStatus = {\n        isHealthy: mcpHealth.isHealthy,\n        lastCheck: new Date(),\n        consecutiveFailures: this.healthStatus.consecutiveFailures,\n        averageLatency: this.metrics.averageLatency,\n        successRate: this.metrics.successRate,\n        queueSize: mcpHealth.queueSize || 0,\n        pendingOperations: mcpHealth.pendingOperations || 0,\n      };\n\n      this.metrics.lastHealthCheck = new Date();\n\n      // Trigger recovery if needed\n      if (\n        !this.healthStatus.isHealthy &&\n        this.healthStatus.consecutiveFailures > 3\n      ) {\n        await this.triggerRecovery();\n      }\n    } catch (error) {\n      this.healthStatus.isHealthy = false;\n      this.healthStatus.lastCheck = new Date();\n    }\n  }\n\n  private async triggerRecovery(): Promise<void> {\n    try {\n      // Attempt to recover MCP connection\n      await this.mcpRouter.reconnect?.();\n\n      // Reset some metrics to give system a fresh start\n      this.healthStatus.consecutiveFailures = Math.max(\n        0,\n        this.healthStatus.consecutiveFailures - 2\n      );\n\n      // Log recovery attempt\n      await this.auditTrail.logEvent({\n        eventType: \"mcp_fallback_recovery_attempt\",\n        correlationId: `recovery-${Date.now()}`,\n        metadata: {\n          healthStatus: this.healthStatus,\n          metrics: this.metrics,\n        },\n      });\n    } catch (error) {\n      // Recovery failed - log it\n      await this.auditTrail.logEvent({\n        eventType: \"mcp_fallback_recovery_failed\",\n        correlationId: `recovery-failed-${Date.now()}`,\n        metadata: {\n          error: (error as Error).message,\n          healthStatus: this.healthStatus,\n        },\n      });\n    }\n  }\n\n  /**\n   * Get current fallback metrics\n   */\n  getFallbackMetrics(): MCPFallbackMetrics {\n    return { ...this.metrics };\n  }\n\n  /**\n   * Get current health status\n   */\n  getHealthStatus(): MCPHealthStatus {\n    return { ...this.healthStatus };\n  }\n\n  /**\n   * Validate if system meets reliability targets\n   */\n  async validateReliabilityTargets(): Promise<ReliabilityValidation> {\n    const meetsTarget =\n      this.metrics.successRate >= this.config.successRateTarget;\n\n    return {\n      meetsTarget,\n      currentSuccessRate: this.metrics.successRate,\n      targetSuccessRate: this.config.successRateTarget,\n      totalOperations: this.metrics.totalFallbackAttempts,\n      recommendations: this.generateRecommendations(),\n      lastValidation: new Date(),\n    };\n  }\n\n  /**\n   * Force health check and recovery\n   */\n  async forceHealthCheckAndRecovery(): Promise<HealthCheckResult> {\n    const previousHealth = { ...this.healthStatus };\n\n    await this.performHealthCheck();\n\n    if (!this.healthStatus.isHealthy) {\n      await this.triggerRecovery();\n      await this.performHealthCheck(); // Check again after recovery\n    }\n\n    const actions: string[] = [];\n    if (!previousHealth.isHealthy && this.healthStatus.isHealthy) {\n      actions.push(\"Health recovered successfully\");\n    } else if (!this.healthStatus.isHealthy) {\n      actions.push(\"Recovery attempted but health still degraded\");\n    } else {\n      actions.push(\"System was already healthy\");\n    }\n\n    return {\n      healthImproved: !previousHealth.isHealthy && this.healthStatus.isHealthy,\n      previousHealth,\n      currentHealth: { ...this.healthStatus },\n      actions,\n      timestamp: new Date(),\n    };\n  }\n\n  /**\n   * Optimize fallback configuration based on performance data\n   */\n  async optimizeFallbackConfiguration(): Promise<ConfigOptimization> {\n    const optimizations: string[] = [];\n    const newConfig: Partial<MCPFallbackConfig> = {};\n    let expectedImprovement = 0;\n    let riskLevel: \"low\" | \"medium\" | \"high\" = \"low\";\n\n    // Analyze recent performance\n    const recentOps = this.operationHistory.slice(-100);\n    const recentSuccessRate =\n      recentOps.filter((op) => op.success).length / recentOps.length;\n    const recentAvgLatency =\n      recentOps.reduce((sum, op) => sum + op.latency, 0) / recentOps.length;\n\n    // Optimize retry configuration\n    if (recentSuccessRate < 0.95 && this.config.maxRetries < 8) {\n      optimizations.push(\"Increase max retries to improve success rate\");\n      newConfig.maxRetries = Math.min(this.config.maxRetries + 2, 8);\n      expectedImprovement += 5;\n      riskLevel = \"medium\";\n    }\n\n    // Optimize timeout configuration\n    if (recentAvgLatency > this.config.performanceThresholds.maxLatency * 0.8) {\n      optimizations.push(\n        \"Increase timeout threshold to reduce timeout failures\"\n      );\n      newConfig.performanceThresholds = {\n        ...this.config.performanceThresholds,\n        maxLatency: Math.min(\n          this.config.performanceThresholds.maxLatency * 1.2,\n          30000\n        ),\n      };\n      expectedImprovement += 3;\n    }\n\n    // Optimize circuit breaker\n    if (this.metrics.circuitBreakerTrips > 2) {\n      optimizations.push(\n        \"Adjust circuit breaker threshold to reduce false positives\"\n      );\n      newConfig.circuitBreakerThreshold = Math.min(\n        this.config.circuitBreakerThreshold + 1,\n        10\n      );\n      expectedImprovement += 2;\n      riskLevel = \"medium\";\n    }\n\n    if (optimizations.length === 0) {\n      optimizations.push(\n        \"Configuration is already optimized for current conditions\"\n      );\n    }\n\n    return {\n      optimizations,\n      newConfig,\n      expectedImprovement,\n      riskLevel,\n    };\n  }\n\n  /**\n   * Get operation history for analysis\n   */\n  getOperationHistory(limit: number = 100): Array<{\n    timestamp: Date;\n    success: boolean;\n    latency: number;\n    error?: string;\n  }> {\n    return this.operationHistory.slice(-limit);\n  }\n\n  private sleep(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Safe audit logging that doesn't throw errors\n   */\n  private async safeAuditLog(event: any): Promise<void> {\n    try {\n      await this.auditTrail.logEvent(event);\n    } catch (error) {\n      // Audit failures should not affect main operation\n      console.warn(\"Audit logging failed:\", error);\n    }\n  }\n\n  /**\n   * Cleanup resources\n   */\n  destroy(): void {\n    if (this.healthCheckTimer) {\n      clearInterval(this.healthCheckTimer);\n      this.healthCheckTimer = undefined;\n    }\n  }\n}\n"],"version":3}