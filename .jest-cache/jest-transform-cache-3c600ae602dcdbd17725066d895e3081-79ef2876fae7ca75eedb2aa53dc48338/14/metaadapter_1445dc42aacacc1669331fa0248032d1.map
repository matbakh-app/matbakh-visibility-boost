{"file":"/Users/matbakh-visibility-boost.20250920/src/lib/ai-orchestrator/adapters/meta-adapter.ts","mappings":"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","names":[],"sources":["/Users/matbakh-visibility-boost.20250920/src/lib/ai-orchestrator/adapters/meta-adapter.ts"],"sourcesContent":["import { ProviderResponse, RouteDecision, ToolSpec } from \"../types\";\nimport { BaseAdapter } from \"./tool-call-adapter\";\n\nexport class MetaAdapter extends BaseAdapter {\n  mapTools(tools?: ToolSpec[]) {\n    // Meta/Llama models have limited tool support\n    // For now, we'll format tools as structured prompts\n    if (!tools?.length) return undefined;\n\n    // Convert tools to structured prompt format for Llama\n    return tools.map((tool) => ({\n      name: tool.name,\n      description: tool.description || \"\",\n      parameters: tool.parameters || {},\n      format: \"structured_prompt\", // Custom format for Llama\n    }));\n  }\n\n  // Enhanced mapping from unified schema to Meta format\n  override fromUnifiedSchema(tools?: UnifiedToolSpec[]): any | undefined {\n    if (!tools?.length) return undefined;\n\n    // Convert unified tools to Meta/Llama format\n    return tools.map((tool) => ({\n      name: tool.function.name,\n      description: tool.function.description || \"\",\n      parameters: tool.function.parameters.properties,\n      format: \"structured_prompt\",\n    }));\n  }\n\n  buildRequest(input: {\n    prompt: string;\n    decision: RouteDecision;\n    streaming?: boolean;\n    maxTokens?: number;\n    tools?: ToolSpec[] | UnifiedToolSpec[];\n  }) {\n    const { prompt, decision, maxTokens, tools } = input;\n\n    // Handle tools by embedding them in the prompt (Llama doesn't support structured tools)\n    let enhancedPrompt = prompt;\n    const toolsToUse = tools || decision.tools;\n    if (toolsToUse?.length) {\n      const toolDescriptions = this.formatToolsForPrompt(toolsToUse);\n      enhancedPrompt = `${prompt}\\n\\nAvailable tools:\\n${toolDescriptions}`;\n    }\n\n    // Format for Llama models (via Bedrock or direct endpoint)\n    const request: any = {\n      prompt: this.formatPromptForLlama(enhancedPrompt),\n      temperature: decision.temperature,\n      max_gen_len: maxTokens || 1024,\n      top_p: 0.9,\n    };\n\n    // Add system prompt for different domains\n    if (\n      prompt.toLowerCase().includes(\"culinary\") ||\n      prompt.toLowerCase().includes(\"food\")\n    ) {\n      request.system_prompt =\n        \"You are a knowledgeable culinary expert. Provide detailed, practical cooking advice and recipes.\";\n    }\n\n    return request;\n  }\n\n  parseResponse(resp: any): ProviderResponse {\n    try {\n      this.validateResponse(resp, \"Meta\");\n\n      // Handle different response formats (Bedrock vs direct)\n      let text = \"\";\n      let tokensUsed = { input: 0, output: 0 };\n\n      if (resp.body) {\n        // Bedrock format\n        const body =\n          typeof resp.body === \"string\" ? JSON.parse(resp.body) : resp.body;\n        text = body.generation || body.generated_text || \"\";\n        tokensUsed = {\n          input: body.prompt_token_count || 0,\n          output: body.generation_token_count || 0,\n        };\n      } else if (resp.generated_text) {\n        // Direct endpoint format\n        text = resp.generated_text;\n        tokensUsed = this.estimateTokens(text);\n      } else if (typeof resp === \"string\") {\n        // Simple string response\n        text = resp;\n        tokensUsed = this.estimateTokens(text);\n      }\n\n      return {\n        text,\n        toolCalls: [], // Llama doesn't support structured tool calls yet\n        raw: resp,\n        tokensUsed,\n      };\n    } catch (error) {\n      this.handleError(error, \"Meta\");\n    }\n  }\n\n  private formatPromptForLlama(prompt: string): string {\n    // Format prompt for Llama models with proper instruction format\n    return `<s>[INST] ${prompt} [/INST]`;\n  }\n\n  getProviderConfig() {\n    return {\n      maxContextTokens: 32768, // Llama 3 70B context window\n      supportsStreaming: false, // Limited streaming support\n      supportsTools: false, // No structured tool calling\n      supportsJsonMode: false, // Limited JSON mode support\n      supportsVision: false, // No vision support\n      rateLimitRpm: 100, // Conservative rate limit\n      fallbackProvider: \"bedrock\", // Fallback to Bedrock if Meta fails\n    };\n  }\n\n  // Meta-specific token estimation\n  override estimateTokens(text: string): { input: number; output: number } {\n    // Llama tokenizer typically uses ~4.2 characters per token\n    const tokens = Math.ceil(text.length / 4.2);\n    return { input: tokens, output: 0 };\n  }\n\n  // Implementation of abstract methods\n  protected extractToolCallsFromResponse(resp: any): Array<{\n    id?: string;\n    name: string;\n    arguments: any;\n    confidence?: number;\n  }> {\n    // Meta/Llama doesn't support structured tool calls\n    // We could implement text parsing for tool-like responses here\n    // For now, return empty array\n    return [];\n  }\n\n  protected getProviderName(): string {\n    return \"meta\";\n  }\n\n  // Enhanced tool feature support for Meta (limited)\n  override supportsToolFeature(\n    feature: \"parallel_calls\" | \"streaming\" | \"json_schema\" | \"complex_types\"\n  ): boolean {\n    // Meta/Llama has very limited tool support\n    return false;\n  }\n\n  // Helper method to format tools for prompt inclusion\n  private formatToolsForPrompt(tools: (ToolSpec | UnifiedToolSpec)[]): string {\n    return tools\n      .map((tool) => {\n        if (\"function\" in tool) {\n          // UnifiedToolSpec\n          const func = tool.function;\n          const params = Object.keys(func.parameters.properties).join(\", \");\n          return `- ${func.name}(${params}): ${func.description}`;\n        } else {\n          // ToolSpec\n          const params = Object.keys(tool.parameters || {}).join(\", \");\n          return `- ${tool.name}(${params}): ${\n            tool.description || \"No description\"\n          }`;\n        }\n      })\n      .join(\"\\n\");\n  }\n\n  // Helper method to check if tools are in unified format\n  private isUnifiedToolSpec(tool: any): tool is UnifiedToolSpec {\n    return tool && typeof tool === \"object\" && \"function\" in tool;\n  }\n\n  // Check if model supports the requested features (legacy method for compatibility)\n  supportsFeature(feature: \"tools\" | \"streaming\" | \"json\" | \"vision\"): boolean {\n    switch (feature) {\n      case \"tools\":\n      case \"json\":\n      case \"vision\":\n        return false;\n      case \"streaming\":\n        return false; // Limited support\n      default:\n        return false;\n    }\n  }\n}\n"],"version":3}