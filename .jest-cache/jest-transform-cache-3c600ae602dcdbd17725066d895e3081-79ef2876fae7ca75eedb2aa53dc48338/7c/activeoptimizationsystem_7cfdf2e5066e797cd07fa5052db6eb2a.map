{"file":"/Users/matbakh-visibility-boost.20250920/src/lib/ai-orchestrator/active-optimization-system.ts","mappings":"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","names":[],"sources":["/Users/matbakh-visibility-boost.20250920/src/lib/ai-orchestrator/active-optimization-system.ts"],"sourcesContent":["/**\n * Active Optimization System\n *\n * Integrates Evidently experiments with bandit optimization to create\n * an active, self-optimizing AI model routing system.\n *\n * Features:\n * - Automatic experiment lifecycle management\n * - Real-time bandit optimization\n * - Performance monitoring and alerting\n * - Auto-scaling based on traffic patterns\n */\n\nimport { Arm, ThompsonBandit } from \"./bandit-controller\";\nimport { BanditOptimizer } from \"./bandit-optimizer\";\nimport {\n  AI_EXPERIMENTS,\n  EvidentlyExperimentManager,\n  ExperimentContext,\n} from \"./evidently-experiments\";\n\nexport interface OptimizationSystemConfig {\n  projectName: string;\n  region: string;\n  autoExperimentEnabled: boolean;\n  experimentDuration: number; // days\n  minTrafficForExperiment: number; // requests per day\n  significanceThreshold: number; // 0-1\n  autoStopEnabled: boolean;\n  autoTrafficAllocationEnabled: boolean; // NEW: Enable automatic traffic allocation\n  trafficAllocationInterval: number; // minutes between traffic allocation updates\n  performanceThresholds: {\n    minWinRate: number;\n    maxLatency: number; // ms\n    maxCost: number; // euro\n  };\n}\n\nexport interface SystemMetrics {\n  totalRequests: number;\n  experimentsActive: number;\n  banditPerformance: {\n    bestArm: Arm;\n    confidence: number;\n    winRate: number;\n  };\n  systemHealth: \"healthy\" | \"warning\" | \"error\";\n  lastOptimization: Date;\n  lastTrafficAllocation: Date; // NEW: Track last traffic allocation update\n  currentTrafficAllocation: Record<Arm, number>; // NEW: Current traffic percentages\n  recommendations: string[];\n}\n\nexport interface OptimizationEvent {\n  timestamp: Date;\n  type:\n    | \"experiment_started\"\n    | \"experiment_stopped\"\n    | \"bandit_updated\"\n    | \"performance_alert\"\n    | \"auto_optimization\"\n    | \"traffic_allocation_updated\"; // NEW: Traffic allocation events\n  details: Record<string, any>;\n  impact: \"low\" | \"medium\" | \"high\";\n}\n\nexport class ActiveOptimizationSystem {\n  private experimentManager: EvidentlyExperimentManager;\n  private banditOptimizer: BanditOptimizer;\n  private config: OptimizationSystemConfig;\n  private metrics: SystemMetrics;\n  private eventHistory: OptimizationEvent[] = [];\n  private isRunning: boolean = false;\n  private optimizationInterval?: NodeJS.Timeout;\n  private trafficAllocationInterval?: NodeJS.Timeout; // NEW: Traffic allocation timer\n\n  constructor(config: Partial<OptimizationSystemConfig> = {}) {\n    this.config = {\n      projectName: \"matbakh-ai-optimization\",\n      region: \"eu-central-1\",\n      autoExperimentEnabled: true,\n      experimentDuration: 14, // 2 weeks\n      minTrafficForExperiment: 100, // 100 requests per day\n      significanceThreshold: 0.95,\n      autoStopEnabled: true,\n      autoTrafficAllocationEnabled: true, // NEW: Enable automatic traffic allocation\n      trafficAllocationInterval: 15, // NEW: Update traffic allocation every 15 minutes\n      performanceThresholds: {\n        minWinRate: 0.7,\n        maxLatency: 2000,\n        maxCost: 0.1,\n      },\n      ...config,\n    };\n\n    // Initialize components\n    const bandit = new ThompsonBandit();\n    this.experimentManager = new EvidentlyExperimentManager(\n      this.config.projectName,\n      this.config.region,\n      bandit\n    );\n    this.banditOptimizer = new BanditOptimizer(bandit, this.experimentManager, {\n      autoOptimizationEnabled: true,\n      explorationRate: 0.15,\n      minTrialsForConfidence: 30,\n      optimizationInterval: 60, // 1 hour\n    });\n\n    this.metrics = {\n      totalRequests: 0,\n      experimentsActive: 0,\n      banditPerformance: {\n        bestArm: \"bedrock\",\n        confidence: 0.5,\n        winRate: 0.5,\n      },\n      systemHealth: \"healthy\",\n      lastOptimization: new Date(),\n      lastTrafficAllocation: new Date(), // NEW: Initialize traffic allocation timestamp\n      currentTrafficAllocation: {\n        // NEW: Initialize equal traffic allocation\n        bedrock: 0.33,\n        google: 0.33,\n        meta: 0.34,\n      },\n      recommendations: [],\n    };\n  }\n\n  /**\n   * Start the active optimization system\n   */\n  async start(): Promise<void> {\n    if (this.isRunning) {\n      console.warn(\"Optimization system is already running\");\n      return;\n    }\n\n    try {\n      // Initialize Evidently project\n      await this.experimentManager.initializeProject();\n\n      // Start initial experiments if enabled\n      if (this.config.autoExperimentEnabled) {\n        await this.startInitialExperiments();\n      }\n\n      // Start optimization loop\n      this.startOptimizationLoop();\n\n      // Start automatic traffic allocation if enabled\n      if (this.config.autoTrafficAllocationEnabled) {\n        this.startTrafficAllocationLoop();\n      }\n\n      this.isRunning = true;\n      this.logEvent({\n        type: \"auto_optimization\",\n        details: { action: \"system_started\", config: this.config },\n        impact: \"high\",\n      });\n\n      console.log(\"Active Optimization System started successfully\");\n    } catch (error) {\n      console.error(\"Failed to start optimization system:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Stop the active optimization system\n   */\n  async stop(): Promise<void> {\n    if (!this.isRunning) {\n      return;\n    }\n\n    // Stop optimization loop\n    if (this.optimizationInterval) {\n      clearInterval(this.optimizationInterval);\n      this.optimizationInterval = undefined;\n    }\n\n    // Stop traffic allocation loop\n    if (this.trafficAllocationInterval) {\n      clearInterval(this.trafficAllocationInterval);\n      this.trafficAllocationInterval = undefined;\n    }\n\n    // Stop active experiments if auto-stop is enabled\n    if (this.config.autoStopEnabled) {\n      const activeExperiments =\n        await this.experimentManager.listActiveExperiments();\n      for (const experimentName of activeExperiments) {\n        await this.experimentManager.stopExperiment(\n          experimentName,\n          \"System shutdown\"\n        );\n      }\n    }\n\n    this.isRunning = false;\n    this.logEvent({\n      type: \"auto_optimization\",\n      details: { action: \"system_stopped\" },\n      impact: \"high\",\n    });\n\n    console.log(\"Active Optimization System stopped\");\n  }\n\n  /**\n   * Get optimal model provider for a request\n   */\n  async getOptimalProvider(context: ExperimentContext): Promise<{\n    provider: Arm;\n    source: \"experiment\" | \"bandit\" | \"traffic_allocation\" | \"default\";\n    confidence: number;\n    experimentName?: string;\n    allocationProbability?: number;\n  }> {\n    try {\n      // Use the new traffic allocation method\n      const result = await this.getOptimalProviderWithTrafficAllocation(\n        context\n      );\n\n      // Update metrics\n      this.metrics.totalRequests++;\n\n      return result;\n    } catch (error) {\n      console.error(\"Failed to get optimal provider:\", error);\n\n      // Fallback to default\n      return {\n        provider: \"bedrock\",\n        source: \"default\",\n        confidence: 0.5,\n      };\n    }\n  }\n\n  /**\n   * Record outcome and trigger optimization\n   */\n  async recordOutcome(\n    context: ExperimentContext,\n    provider: Arm,\n    metrics: {\n      success: boolean;\n      latencyMs: number;\n      costEuro: number;\n      qualityScore?: number;\n      userSatisfaction?: number;\n    }\n  ): Promise<void> {\n    try {\n      // Record in optimizer\n      await this.banditOptimizer.recordOutcome(\n        context,\n        provider,\n        metrics.success,\n        metrics.latencyMs,\n        metrics.costEuro,\n        metrics.qualityScore\n      );\n\n      // Check for performance alerts\n      await this.checkPerformanceAlerts(provider, metrics);\n\n      // Update system metrics\n      await this.updateSystemMetrics();\n    } catch (error) {\n      console.error(\"Failed to record outcome:\", error);\n    }\n  }\n\n  /**\n   * Get current system metrics\n   */\n  getMetrics(): SystemMetrics {\n    return { ...this.metrics };\n  }\n\n  /**\n   * Get optimization event history\n   */\n  getEventHistory(limit: number = 100): OptimizationEvent[] {\n    return this.eventHistory.slice(-limit);\n  }\n\n  /**\n   * Force optimization cycle\n   */\n  async forceOptimization(): Promise<void> {\n    await this.runOptimizationCycle();\n  }\n\n  /**\n   * Get system health status\n   */\n  async getHealthStatus(): Promise<{\n    system: \"healthy\" | \"warning\" | \"error\";\n    components: {\n      experiments: \"healthy\" | \"warning\" | \"error\";\n      bandit: \"healthy\" | \"warning\" | \"error\";\n      optimization: \"healthy\" | \"warning\" | \"error\";\n    };\n    details: Record<string, any>;\n  }> {\n    try {\n      const [experimentHealth, banditHealth] = await Promise.all([\n        this.experimentManager.healthCheck(),\n        Promise.resolve(this.banditOptimizer.healthCheck()),\n      ]);\n\n      const components = {\n        experiments: experimentHealth.connected\n          ? (\"healthy\" as const)\n          : (\"error\" as const),\n        bandit: banditHealth.status,\n        optimization: this.isRunning\n          ? (\"healthy\" as const)\n          : (\"warning\" as const),\n      };\n\n      const systemHealth = Object.values(components).includes(\"error\")\n        ? \"error\"\n        : Object.values(components).includes(\"warning\")\n        ? \"warning\"\n        : \"healthy\";\n\n      return {\n        system: systemHealth,\n        components,\n        details: {\n          experimentHealth,\n          banditHealth,\n          isRunning: this.isRunning,\n          totalRequests: this.metrics.totalRequests,\n          lastOptimization: this.metrics.lastOptimization,\n        },\n      };\n    } catch (error) {\n      return {\n        system: \"error\",\n        components: {\n          experiments: \"error\",\n          bandit: \"error\",\n          optimization: \"error\",\n        },\n        details: { error: error.message },\n      };\n    }\n  }\n\n  /**\n   * Start initial experiments\n   */\n  private async startInitialExperiments(): Promise<void> {\n    try {\n      // Start model routing optimization experiment\n      const routingExperiment = AI_EXPERIMENTS.MODEL_ROUTING_OPTIMIZATION;\n      await this.experimentManager.createAIExperiment(routingExperiment);\n      await this.experimentManager.startExperiment(routingExperiment.name);\n\n      this.logEvent({\n        type: \"experiment_started\",\n        details: {\n          experimentName: routingExperiment.name,\n          type: \"model_routing\",\n        },\n        impact: \"medium\",\n      });\n\n      // Start domain-specific routing experiment\n      const domainExperiment = AI_EXPERIMENTS.DOMAIN_SPECIFIC_ROUTING;\n      await this.experimentManager.createAIExperiment(domainExperiment);\n      await this.experimentManager.startExperiment(domainExperiment.name);\n\n      this.logEvent({\n        type: \"experiment_started\",\n        details: {\n          experimentName: domainExperiment.name,\n          type: \"domain_specific\",\n        },\n        impact: \"medium\",\n      });\n\n      console.log(\"Initial experiments started successfully\");\n    } catch (error) {\n      console.error(\"Failed to start initial experiments:\", error);\n    }\n  }\n\n  /**\n   * Start optimization loop\n   */\n  private startOptimizationLoop(): void {\n    this.optimizationInterval = setInterval(async () => {\n      await this.runOptimizationCycle();\n    }, 30 * 60 * 1000); // Every 30 minutes\n  }\n\n  /**\n   * Start automatic traffic allocation loop\n   */\n  private startTrafficAllocationLoop(): void {\n    this.trafficAllocationInterval = setInterval(async () => {\n      await this.updateTrafficAllocation();\n    }, this.config.trafficAllocationInterval * 60 * 1000); // Convert minutes to ms\n  }\n\n  /**\n   * Run a single optimization cycle\n   */\n  private async runOptimizationCycle(): Promise<void> {\n    try {\n      console.log(\"Running optimization cycle...\");\n\n      // Update system metrics\n      await this.updateSystemMetrics();\n\n      // Check for experiment completion\n      await this.checkExperimentCompletion();\n\n      // Get optimization recommendations\n      const recommendations =\n        this.banditOptimizer.getOptimizationRecommendations();\n      this.metrics.recommendations = recommendations.map((r) => r.description);\n\n      // Apply automatic optimizations\n      await this.applyAutoOptimizations(recommendations);\n\n      // Check if new experiments should be started\n      if (this.config.autoExperimentEnabled) {\n        await this.checkForNewExperiments();\n      }\n\n      this.metrics.lastOptimization = new Date();\n\n      this.logEvent({\n        type: \"auto_optimization\",\n        details: {\n          recommendations: recommendations.length,\n          systemHealth: this.metrics.systemHealth,\n        },\n        impact: \"low\",\n      });\n    } catch (error) {\n      console.error(\"Error in optimization cycle:\", error);\n      this.metrics.systemHealth = \"error\";\n    }\n  }\n\n  /**\n   * Update system metrics\n   */\n  private async updateSystemMetrics(): Promise<void> {\n    try {\n      // Get active experiments count\n      const activeExperiments =\n        await this.experimentManager.listActiveExperiments();\n      this.metrics.experimentsActive = activeExperiments.length;\n\n      // Get bandit performance\n      const banditStats = this.banditOptimizer.getBanditStats();\n      const bestArm = Object.entries(banditStats).reduce(\n        (best, [arm, stats]) => {\n          return stats.winRate > best.stats.winRate\n            ? { arm: arm as Arm, stats }\n            : best;\n        },\n        { arm: \"bedrock\" as Arm, stats: banditStats.bedrock }\n      );\n\n      this.metrics.banditPerformance = {\n        bestArm: bestArm.arm,\n        confidence:\n          bestArm.stats.trials > 30\n            ? Math.min(0.95, bestArm.stats.winRate + 0.1)\n            : 0.5,\n        winRate: bestArm.stats.winRate,\n      };\n\n      // Update system health\n      const health = await this.getHealthStatus();\n      this.metrics.systemHealth = health.system;\n    } catch (error) {\n      console.error(\"Failed to update system metrics:\", error);\n      this.metrics.systemHealth = \"error\";\n    }\n  }\n\n  /**\n   * Check for performance alerts\n   */\n  private async checkPerformanceAlerts(\n    provider: Arm,\n    metrics: {\n      success: boolean;\n      latencyMs: number;\n      costEuro: number;\n      qualityScore?: number;\n    }\n  ): Promise<void> {\n    const { performanceThresholds } = this.config;\n    const alerts = [];\n\n    // Check latency\n    if (metrics.latencyMs > performanceThresholds.maxLatency) {\n      alerts.push(\n        `High latency: ${metrics.latencyMs}ms > ${performanceThresholds.maxLatency}ms`\n      );\n    }\n\n    // Check cost\n    if (metrics.costEuro > performanceThresholds.maxCost) {\n      alerts.push(\n        `High cost: €${metrics.costEuro} > €${performanceThresholds.maxCost}`\n      );\n    }\n\n    // Check success rate (approximate)\n    const banditStats = this.banditOptimizer.getBanditStats();\n    const providerStats = banditStats[provider];\n    if (\n      providerStats.winRate < performanceThresholds.minWinRate &&\n      providerStats.trials > 10\n    ) {\n      alerts.push(\n        `Low win rate: ${(providerStats.winRate * 100).toFixed(1)}% < ${(\n          performanceThresholds.minWinRate * 100\n        ).toFixed(1)}%`\n      );\n    }\n\n    // Log alerts\n    if (alerts.length > 0) {\n      this.logEvent({\n        type: \"performance_alert\",\n        details: { provider, alerts, metrics },\n        impact: \"medium\",\n      });\n\n      console.warn(`Performance alerts for ${provider}:`, alerts);\n    }\n  }\n\n  /**\n   * Check for experiment completion\n   */\n  private async checkExperimentCompletion(): Promise<void> {\n    try {\n      const activeExperiments =\n        await this.experimentManager.listActiveExperiments();\n\n      for (const experimentName of activeExperiments) {\n        const result = await this.experimentManager.analyzeExperimentResults(\n          experimentName\n        );\n\n        if (\n          result?.recommendation &&\n          result.recommendation.confidence > this.config.significanceThreshold\n        ) {\n          // High confidence result found\n          if (this.config.autoStopEnabled) {\n            await this.experimentManager.stopExperiment(\n              experimentName,\n              `Auto-stop: High confidence winner (${result.recommendation.confidence})`\n            );\n\n            this.logEvent({\n              type: \"experiment_stopped\",\n              details: {\n                experimentName,\n                winner: result.recommendation.winningTreatment,\n                confidence: result.recommendation.confidence,\n                reason: \"auto_stop_high_confidence\",\n              },\n              impact: \"high\",\n            });\n          }\n        }\n      }\n    } catch (error) {\n      console.error(\"Failed to check experiment completion:\", error);\n    }\n  }\n\n  /**\n   * Apply automatic optimizations\n   */\n  private async applyAutoOptimizations(\n    recommendations: ReturnType<\n      BanditOptimizer[\"getOptimizationRecommendations\"]\n    >\n  ): Promise<void> {\n    const highPriorityRecs = recommendations.filter(\n      (r) => r.priority === \"high\"\n    );\n\n    for (const rec of highPriorityRecs) {\n      try {\n        if (rec.type === \"exploration\") {\n          // Increase exploration temporarily\n          const currentConfig = this.banditOptimizer.getConfig();\n          this.banditOptimizer.updateConfig({\n            explorationRate: Math.min(0.3, currentConfig.explorationRate * 1.5),\n          });\n\n          this.logEvent({\n            type: \"auto_optimization\",\n            details: {\n              action: \"increased_exploration\",\n              newRate: this.banditOptimizer.getConfig().explorationRate,\n            },\n            impact: \"medium\",\n          });\n\n          // Reset after 2 hours\n          setTimeout(() => {\n            this.banditOptimizer.updateConfig({\n              explorationRate: Math.max(0.05, currentConfig.explorationRate),\n            });\n          }, 2 * 60 * 60 * 1000);\n        }\n      } catch (error) {\n        console.error(`Failed to apply optimization: ${rec.type}`, error);\n      }\n    }\n  }\n\n  /**\n   * Check if new experiments should be started\n   */\n  private async checkForNewExperiments(): Promise<void> {\n    try {\n      // Only start new experiments if traffic is sufficient\n      if (this.metrics.totalRequests < this.config.minTrafficForExperiment) {\n        return;\n      }\n\n      const activeExperiments =\n        await this.experimentManager.listActiveExperiments();\n\n      // Don't start too many experiments at once\n      if (activeExperiments.length >= 2) {\n        return;\n      }\n\n      // Check if we should start context-specific experiments\n      const contextualPerformance =\n        this.banditOptimizer.analyzeContextualPerformance();\n      const promisingContexts = contextualPerformance.filter(\n        (ctx) =>\n          ctx.improvement > 0.2 && ctx.armPerformance[ctx.bestArm].trials > 50\n      );\n\n      if (promisingContexts.length > 0) {\n        // Could implement context-specific experiment creation here\n        console.log(\n          \"Promising contexts found for new experiments:\",\n          promisingContexts.map((c) => c.context)\n        );\n      }\n    } catch (error) {\n      console.error(\"Failed to check for new experiments:\", error);\n    }\n  }\n\n  /**\n   * Log optimization event\n   */\n  private logEvent(event: Omit<OptimizationEvent, \"timestamp\">): void {\n    const fullEvent: OptimizationEvent = {\n      timestamp: new Date(),\n      ...event,\n    };\n\n    this.eventHistory.push(fullEvent);\n\n    // Keep only last 1000 events\n    if (this.eventHistory.length > 1000) {\n      this.eventHistory = this.eventHistory.slice(-1000);\n    }\n\n    // Log high impact events\n    if (event.impact === \"high\") {\n      console.log(`[OPTIMIZATION] ${event.type}:`, event.details);\n    }\n  }\n\n  /**\n   * Get configuration\n   */\n  getConfig(): OptimizationSystemConfig {\n    return { ...this.config };\n  }\n\n  /**\n   * Update configuration\n   */\n  updateConfig(updates: Partial<OptimizationSystemConfig>): void {\n    this.config = { ...this.config, ...updates };\n\n    this.logEvent({\n      type: \"auto_optimization\",\n      details: { action: \"config_updated\", updates },\n      impact: \"medium\",\n    });\n  }\n\n  /**\n   * Update traffic allocation automatically based on performance\n   */\n  private async updateTrafficAllocation(): Promise<void> {\n    try {\n      console.log(\"Updating automatic traffic allocation...\");\n\n      const banditStats = this.banditOptimizer.getBanditStats();\n      const contextualPerformance =\n        this.banditOptimizer.analyzeContextualPerformance();\n\n      // Calculate performance scores for each arm\n      const armScores = this.calculateArmPerformanceScores(banditStats);\n\n      // Calculate new traffic allocation based on performance\n      const newAllocation = this.calculateOptimalTrafficAllocation(\n        armScores,\n        banditStats\n      );\n\n      // Apply smoothing to prevent dramatic changes\n      const smoothedAllocation = this.smoothTrafficAllocation(\n        this.metrics.currentTrafficAllocation,\n        newAllocation\n      );\n\n      // Update traffic allocation\n      const previousAllocation = { ...this.metrics.currentTrafficAllocation };\n      this.metrics.currentTrafficAllocation = smoothedAllocation;\n      this.metrics.lastTrafficAllocation = new Date();\n\n      // Log the change\n      this.logEvent({\n        type: \"traffic_allocation_updated\",\n        details: {\n          previousAllocation,\n          newAllocation: smoothedAllocation,\n          armScores,\n          reason: \"automatic_performance_optimization\",\n        },\n        impact: \"medium\",\n      });\n\n      console.log(\"Traffic allocation updated:\", {\n        previous: previousAllocation,\n        new: smoothedAllocation,\n        scores: armScores,\n      });\n    } catch (error) {\n      console.error(\"Failed to update traffic allocation:\", error);\n\n      this.logEvent({\n        type: \"traffic_allocation_updated\",\n        details: {\n          error: error.message,\n          reason: \"allocation_update_failed\",\n        },\n        impact: \"high\",\n      });\n    }\n  }\n\n  /**\n   * Calculate performance scores for each arm\n   */\n  private calculateArmPerformanceScores(\n    banditStats: Record<Arm, any>\n  ): Record<Arm, number> {\n    const scores: Record<Arm, number> = {} as any;\n\n    (Object.keys(banditStats) as Arm[]).forEach((arm) => {\n      const stats = banditStats[arm];\n\n      if (stats.trials === 0) {\n        // No data yet, give neutral score\n        scores[arm] = 0.5;\n        return;\n      }\n\n      // Composite score based on multiple factors\n      const winRateScore = stats.winRate; // 0-1\n      const latencyScore = Math.max(0, 1 - stats.avgLatency / 3000); // Normalize to 0-1, 3s = 0\n      const costScore = Math.max(0, 1 - stats.avgCost / 0.2); // Normalize to 0-1, €0.2 = 0\n      const confidenceScore = Math.min(1, stats.trials / 50); // More trials = higher confidence\n\n      // Weighted composite score\n      scores[arm] =\n        winRateScore * 0.4 + // 40% win rate\n        latencyScore * 0.3 + // 30% latency\n        costScore * 0.2 + // 20% cost\n        confidenceScore * 0.1; // 10% confidence\n    });\n\n    return scores;\n  }\n\n  /**\n   * Calculate optimal traffic allocation based on performance scores\n   */\n  private calculateOptimalTrafficAllocation(\n    armScores: Record<Arm, number>,\n    banditStats: Record<Arm, any>\n  ): Record<Arm, number> {\n    const arms: Arm[] = [\"bedrock\", \"google\", \"meta\"];\n    const allocation: Record<Arm, number> = {} as any;\n\n    // Get total score\n    const totalScore = arms.reduce((sum, arm) => sum + armScores[arm], 0);\n\n    if (totalScore === 0) {\n      // No performance data, use equal allocation\n      arms.forEach((arm) => {\n        allocation[arm] = 1 / arms.length;\n      });\n      return allocation;\n    }\n\n    // Calculate base allocation based on performance scores\n    arms.forEach((arm) => {\n      allocation[arm] = armScores[arm] / totalScore;\n    });\n\n    // Apply exploration bonus for under-explored arms\n    const minTrials = Math.min(...arms.map((arm) => banditStats[arm].trials));\n    const maxTrials = Math.max(...arms.map((arm) => banditStats[arm].trials));\n\n    if (maxTrials > 0) {\n      arms.forEach((arm) => {\n        const trials = banditStats[arm].trials;\n        const explorationBonus = (maxTrials - trials) / (maxTrials * 10); // Small bonus for under-explored arms\n        allocation[arm] += explorationBonus;\n      });\n    }\n\n    // Ensure minimum allocation for each arm (at least 5%)\n    const minAllocation = 0.05;\n    arms.forEach((arm) => {\n      allocation[arm] = Math.max(minAllocation, allocation[arm]);\n    });\n\n    // Normalize to ensure sum = 1\n    const sum = arms.reduce((total, arm) => total + allocation[arm], 0);\n    arms.forEach((arm) => {\n      allocation[arm] = allocation[arm] / sum;\n    });\n\n    return allocation;\n  }\n\n  /**\n   * Apply smoothing to prevent dramatic traffic allocation changes\n   */\n  private smoothTrafficAllocation(\n    currentAllocation: Record<Arm, number>,\n    targetAllocation: Record<Arm, number>,\n    smoothingFactor: number = 0.3 // How much to move toward target (0-1)\n  ): Record<Arm, number> {\n    const smoothedAllocation: Record<Arm, number> = {} as any;\n\n    (Object.keys(currentAllocation) as Arm[]).forEach((arm) => {\n      const current = currentAllocation[arm];\n      const target = targetAllocation[arm];\n\n      // Move toward target by smoothingFactor\n      smoothedAllocation[arm] = current + (target - current) * smoothingFactor;\n    });\n\n    // Normalize to ensure sum = 1\n    const sum = Object.values(smoothedAllocation).reduce(\n      (total, val) => total + val,\n      0\n    );\n    (Object.keys(smoothedAllocation) as Arm[]).forEach((arm) => {\n      smoothedAllocation[arm] = smoothedAllocation[arm] / sum;\n    });\n\n    return smoothedAllocation;\n  }\n\n  /**\n   * Get optimal provider with automatic traffic allocation\n   */\n  async getOptimalProviderWithTrafficAllocation(\n    context: ExperimentContext\n  ): Promise<{\n    provider: Arm;\n    source: \"experiment\" | \"bandit\" | \"traffic_allocation\" | \"default\";\n    confidence: number;\n    experimentName?: string;\n    allocationProbability?: number;\n  }> {\n    try {\n      // First check for active experiments\n      if (this.experimentManager) {\n        try {\n          const experimentResult =\n            await this.experimentManager.getOptimalProvider(context);\n          if (experimentResult.source === \"experiment\") {\n            return {\n              provider: experimentResult.provider,\n              source: \"experiment\",\n              confidence: experimentResult.confidence,\n              experimentName: experimentResult.experimentName,\n            };\n          }\n        } catch (error) {\n          console.warn(\n            \"Failed to get experiment assignment, falling back to traffic allocation:\",\n            error\n          );\n        }\n      }\n\n      // Use automatic traffic allocation if enabled\n      if (this.config.autoTrafficAllocationEnabled) {\n        const selectedArm = this.selectArmByTrafficAllocation();\n        const allocationProbability =\n          this.metrics.currentTrafficAllocation[selectedArm];\n\n        return {\n          provider: selectedArm,\n          source: \"traffic_allocation\",\n          confidence: Math.min(0.95, allocationProbability + 0.2), // Higher allocation = higher confidence\n          allocationProbability,\n        };\n      }\n\n      // Fall back to bandit optimization\n      const result = await this.banditOptimizer.getOptimalArm(context);\n      return {\n        provider: result.recommendedArm,\n        source: \"bandit\",\n        confidence: result.confidence,\n      };\n    } catch (error) {\n      console.error(\"Failed to get optimal provider:\", error);\n      return {\n        provider: \"bedrock\",\n        source: \"default\",\n        confidence: 0.5,\n      };\n    }\n  }\n\n  /**\n   * Select arm based on current traffic allocation probabilities\n   */\n  private selectArmByTrafficAllocation(): Arm {\n    const random = Math.random();\n    let cumulativeProbability = 0;\n\n    const arms: Arm[] = [\"bedrock\", \"google\", \"meta\"];\n\n    for (const arm of arms) {\n      cumulativeProbability += this.metrics.currentTrafficAllocation[arm];\n      if (random <= cumulativeProbability) {\n        return arm;\n      }\n    }\n\n    // Fallback (should not happen with proper normalization)\n    return \"bedrock\";\n  }\n\n  /**\n   * Force traffic allocation update\n   */\n  async forceTrafficAllocationUpdate(): Promise<void> {\n    await this.updateTrafficAllocation();\n  }\n\n  /**\n   * Get current traffic allocation\n   */\n  getCurrentTrafficAllocation(): Record<Arm, number> {\n    return { ...this.metrics.currentTrafficAllocation };\n  }\n\n  /**\n   * Export system state for persistence\n   */\n  exportState(): {\n    config: OptimizationSystemConfig;\n    metrics: SystemMetrics;\n    banditState: ReturnType<BanditOptimizer[\"exportState\"]>;\n    eventHistory: OptimizationEvent[];\n  } {\n    return {\n      config: this.config,\n      metrics: this.metrics,\n      banditState: this.banditOptimizer.exportState(),\n      eventHistory: this.eventHistory,\n    };\n  }\n}\n\n// Singleton instance for global use\nlet globalOptimizationSystem: ActiveOptimizationSystem | null = null;\n\n/**\n * Get or create the global optimization system\n */\nexport function getOptimizationSystem(\n  config?: Partial<OptimizationSystemConfig>\n): ActiveOptimizationSystem {\n  if (!globalOptimizationSystem) {\n    globalOptimizationSystem = new ActiveOptimizationSystem(config);\n  }\n  return globalOptimizationSystem;\n}\n\n/**\n * Initialize and start the global optimization system\n */\nexport async function initializeOptimizationSystem(\n  config?: Partial<OptimizationSystemConfig>\n): Promise<ActiveOptimizationSystem> {\n  const system = getOptimizationSystem(config);\n\n  if (!system[\"isRunning\"]) {\n    await system.start();\n  }\n\n  return system;\n}\n\n/**\n * Shutdown the global optimization system\n */\nexport async function shutdownOptimizationSystem(): Promise<void> {\n  if (globalOptimizationSystem) {\n    await globalOptimizationSystem.stop();\n    globalOptimizationSystem = null;\n  }\n}\n"],"version":3}