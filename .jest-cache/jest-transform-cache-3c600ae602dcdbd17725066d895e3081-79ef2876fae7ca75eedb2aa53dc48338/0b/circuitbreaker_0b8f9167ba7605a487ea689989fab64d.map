{"file":"/Users/matbakh-visibility-boost.20250920/src/lib/ai-orchestrator/circuit-breaker.ts","mappings":"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","names":[],"sources":["/Users/matbakh-visibility-boost.20250920/src/lib/ai-orchestrator/circuit-breaker.ts"],"sourcesContent":["/**\n * Circuit Breaker Pattern Implementation\n *\n * Implements:\n * - Circuit breaker for provider resilience\n * - Automatic failure detection and recovery\n * - Configurable thresholds and timeouts\n * - Health check integration\n * - Fallback mechanism coordination\n */\n\nimport { Provider } from \"./types\";\n\nexport interface CircuitBreakerConfig {\n  failureThreshold: number;\n  recoveryTimeout: number;\n  monitoringWindow: number;\n  halfOpenMaxCalls: number;\n  healthCheckInterval: number;\n}\n\nexport interface CircuitBreakerState {\n  provider: Provider;\n  state: \"closed\" | \"open\" | \"half-open\";\n  failureCount: number;\n  lastFailureTime: number;\n  lastSuccessTime: number;\n  nextAttemptTime: number;\n  totalRequests: number;\n  successfulRequests: number;\n  halfOpenAttempts: number;\n}\n\nexport interface CircuitBreakerMetrics {\n  provider: Provider;\n  state: \"closed\" | \"open\" | \"half-open\";\n  failureRate: number;\n  uptime: number;\n  lastFailure: Date | null;\n  lastSuccess: Date | null;\n  totalFailures: number;\n  totalSuccesses: number;\n  circuitOpenTime: number;\n}\n\n/**\n * Circuit Breaker for Provider Resilience\n */\nexport class CircuitBreaker {\n  private config: CircuitBreakerConfig;\n  private states: Map<Provider, CircuitBreakerState> = new Map();\n  private healthCheckTimers: Map<Provider, NodeJS.Timeout> = new Map();\n\n  constructor(config: Partial<CircuitBreakerConfig> = {}) {\n    this.config = {\n      failureThreshold: 5, // Open circuit after 5 failures\n      recoveryTimeout: 60000, // 1 minute recovery timeout\n      monitoringWindow: 300000, // 5 minute monitoring window\n      halfOpenMaxCalls: 3, // Max calls in half-open state\n      healthCheckInterval: 30000, // 30 second health check interval\n      ...config,\n    };\n\n    this.initializeProviders();\n  }\n\n  /**\n   * Check if circuit breaker is open for a provider\n   */\n  isOpen(provider: Provider): boolean {\n    const state = this.getState(provider);\n    return state.state === \"open\";\n  }\n\n  /**\n   * Execute request through circuit breaker\n   */\n  async execute<T>(\n    provider: Provider,\n    operation: () => Promise<T>\n  ): Promise<T> {\n    const state = this.getState(provider);\n\n    // Check if circuit is open\n    if (state.state === \"open\") {\n      if (Date.now() < state.nextAttemptTime) {\n        throw new Error(\n          `Circuit breaker is OPEN for provider ${provider}. Next attempt at ${new Date(\n            state.nextAttemptTime\n          )}`\n        );\n      } else {\n        // Transition to half-open\n        this.transitionToHalfOpen(provider);\n      }\n    }\n\n    // Check half-open limits\n    if (\n      state.state === \"half-open\" &&\n      state.halfOpenAttempts >= this.config.halfOpenMaxCalls\n    ) {\n      throw new Error(\n        `Circuit breaker is HALF-OPEN for provider ${provider}. Max attempts reached.`\n      );\n    }\n\n    try {\n      // Execute the operation\n      const startTime = Date.now();\n      const result = await operation();\n      const latency = Date.now() - startTime;\n\n      // Record success\n      this.recordSuccess(provider, latency);\n\n      return result;\n    } catch (error) {\n      // Record failure\n      this.recordFailure(provider, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Record successful operation\n   */\n  private recordSuccess(provider: Provider, latency: number): void {\n    const state = this.getState(provider);\n\n    state.successfulRequests++;\n    state.totalRequests++;\n    state.lastSuccessTime = Date.now();\n\n    // Reset failure count on success\n    state.failureCount = 0;\n\n    // Transition from half-open to closed if successful\n    if (state.state === \"half-open\") {\n      state.halfOpenAttempts++;\n\n      // If we've had enough successful attempts, close the circuit\n      if (state.halfOpenAttempts >= this.config.halfOpenMaxCalls) {\n        this.transitionToClosed(provider);\n      }\n    }\n\n    this.updateState(provider, state);\n  }\n\n  /**\n   * Record failed operation\n   */\n  private recordFailure(provider: Provider, error: any): void {\n    const state = this.getState(provider);\n\n    state.failureCount++;\n    state.totalRequests++;\n    state.lastFailureTime = Date.now();\n\n    // Check if we should open the circuit\n    if (\n      state.state === \"closed\" &&\n      state.failureCount >= this.config.failureThreshold\n    ) {\n      this.transitionToOpen(provider);\n    } else if (state.state === \"half-open\") {\n      // Any failure in half-open state should open the circuit\n      this.transitionToOpen(provider);\n    }\n\n    this.updateState(provider, state);\n  }\n\n  /**\n   * Transition circuit to OPEN state\n   */\n  private transitionToOpen(provider: Provider): void {\n    const state = this.getState(provider);\n\n    state.state = \"open\";\n    state.nextAttemptTime = Date.now() + this.config.recoveryTimeout;\n    state.halfOpenAttempts = 0;\n\n    console.warn(\n      `Circuit breaker OPENED for provider ${provider}. Next attempt at ${new Date(\n        state.nextAttemptTime\n      )}`\n    );\n\n    // Start health check timer\n    this.startHealthCheck(provider);\n\n    this.updateState(provider, state);\n  }\n\n  /**\n   * Transition circuit to HALF-OPEN state\n   */\n  private transitionToHalfOpen(provider: Provider): void {\n    const state = this.getState(provider);\n\n    state.state = \"half-open\";\n    state.halfOpenAttempts = 0;\n\n    console.info(\n      `Circuit breaker transitioned to HALF-OPEN for provider ${provider}`\n    );\n\n    this.updateState(provider, state);\n  }\n\n  /**\n   * Transition circuit to CLOSED state\n   */\n  private transitionToClosed(provider: Provider): void {\n    const state = this.getState(provider);\n\n    state.state = \"closed\";\n    state.failureCount = 0;\n    state.halfOpenAttempts = 0;\n\n    console.info(`Circuit breaker CLOSED for provider ${provider}`);\n\n    // Stop health check timer\n    this.stopHealthCheck(provider);\n\n    this.updateState(provider, state);\n  }\n\n  /**\n   * Start health check for provider\n   */\n  private startHealthCheck(provider: Provider): void {\n    this.stopHealthCheck(provider); // Clear any existing timer\n\n    const timer = setInterval(async () => {\n      try {\n        const healthy = await this.performHealthCheck(provider);\n\n        if (healthy) {\n          console.info(\n            `Health check passed for provider ${provider}. Transitioning to HALF-OPEN.`\n          );\n          this.transitionToHalfOpen(provider);\n        }\n      } catch (error) {\n        console.warn(`Health check failed for provider ${provider}:`, error);\n      }\n    }, this.config.healthCheckInterval);\n\n    this.healthCheckTimers.set(provider, timer);\n  }\n\n  /**\n   * Stop health check for provider\n   */\n  private stopHealthCheck(provider: Provider): void {\n    const timer = this.healthCheckTimers.get(provider);\n    if (timer) {\n      clearInterval(timer);\n      this.healthCheckTimers.delete(provider);\n    }\n  }\n\n  /**\n   * Perform health check for provider\n   */\n  private async performHealthCheck(provider: Provider): Promise<boolean> {\n    // In production, this would make actual health check requests\n    // For now, simulate health check\n\n    const state = this.getState(provider);\n    const timeSinceLastFailure = Date.now() - state.lastFailureTime;\n\n    // Simple heuristic: if it's been long enough since last failure, consider healthy\n    return timeSinceLastFailure > this.config.recoveryTimeout;\n  }\n\n  /**\n   * Get circuit breaker state for provider\n   */\n  private getState(provider: Provider): CircuitBreakerState {\n    let state = this.states.get(provider);\n\n    if (!state) {\n      state = {\n        provider,\n        state: \"closed\",\n        failureCount: 0,\n        lastFailureTime: 0,\n        lastSuccessTime: Date.now(),\n        nextAttemptTime: 0,\n        totalRequests: 0,\n        successfulRequests: 0,\n        halfOpenAttempts: 0,\n      };\n\n      this.states.set(provider, state);\n    }\n\n    return state;\n  }\n\n  /**\n   * Update state for provider\n   */\n  private updateState(provider: Provider, state: CircuitBreakerState): void {\n    this.states.set(provider, state);\n  }\n\n  /**\n   * Check if provider is available\n   */\n  isAvailable(provider: Provider): boolean {\n    const state = this.getState(provider);\n\n    if (state.state === \"closed\") {\n      return true;\n    }\n\n    if (state.state === \"half-open\") {\n      return state.halfOpenAttempts < this.config.halfOpenMaxCalls;\n    }\n\n    if (state.state === \"open\") {\n      return Date.now() >= state.nextAttemptTime;\n    }\n\n    return false;\n  }\n\n  /**\n   * Get circuit breaker metrics for provider\n   */\n  getMetrics(provider: Provider): CircuitBreakerMetrics {\n    const state = this.getState(provider);\n\n    const failureRate =\n      state.totalRequests > 0\n        ? (state.totalRequests - state.successfulRequests) / state.totalRequests\n        : 0;\n\n    const uptime =\n      state.totalRequests > 0\n        ? state.successfulRequests / state.totalRequests\n        : 1;\n\n    const circuitOpenTime =\n      state.state === \"open\" ? Date.now() - state.lastFailureTime : 0;\n\n    return {\n      provider,\n      state: state.state,\n      failureRate,\n      uptime,\n      lastFailure:\n        state.lastFailureTime > 0 ? new Date(state.lastFailureTime) : null,\n      lastSuccess:\n        state.lastSuccessTime > 0 ? new Date(state.lastSuccessTime) : null,\n      totalFailures: state.totalRequests - state.successfulRequests,\n      totalSuccesses: state.successfulRequests,\n      circuitOpenTime,\n    };\n  }\n\n  /**\n   * Get all circuit breaker metrics\n   */\n  getAllMetrics(): CircuitBreakerMetrics[] {\n    const providers: Provider[] = [\"bedrock\", \"google\", \"meta\"];\n    return providers.map((provider) => this.getMetrics(provider));\n  }\n\n  /**\n   * Get available providers\n   */\n  getAvailableProviders(): Provider[] {\n    const providers: Provider[] = [\"bedrock\", \"google\", \"meta\"];\n    return providers.filter((provider) => this.isAvailable(provider));\n  }\n\n  /**\n   * Force open circuit for provider (for testing/maintenance)\n   */\n  forceOpen(provider: Provider): void {\n    const state = this.getState(provider);\n    state.state = \"open\";\n    state.nextAttemptTime = Date.now() + this.config.recoveryTimeout;\n\n    console.warn(`Circuit breaker FORCE OPENED for provider ${provider}`);\n\n    this.startHealthCheck(provider);\n    this.updateState(provider, state);\n  }\n\n  /**\n   * Force close circuit for provider (for testing/maintenance)\n   */\n  forceClose(provider: Provider): void {\n    const state = this.getState(provider);\n    state.state = \"closed\";\n    state.failureCount = 0;\n    state.halfOpenAttempts = 0;\n\n    console.info(`Circuit breaker FORCE CLOSED for provider ${provider}`);\n\n    this.stopHealthCheck(provider);\n    this.updateState(provider, state);\n  }\n\n  /**\n   * Reset circuit breaker for provider\n   */\n  reset(provider: Provider): void {\n    this.stopHealthCheck(provider);\n    this.states.delete(provider);\n\n    console.info(`Circuit breaker RESET for provider ${provider}`);\n  }\n\n  /**\n   * Reset all circuit breakers\n   */\n  resetAll(): void {\n    const providers: Provider[] = [\"bedrock\", \"google\", \"meta\"];\n    providers.forEach((provider) => this.reset(provider));\n  }\n\n  /**\n   * Initialize providers\n   */\n  private initializeProviders(): void {\n    const providers: Provider[] = [\"bedrock\", \"google\", \"meta\"];\n    providers.forEach((provider) => this.getState(provider));\n  }\n\n  /**\n   * Cleanup resources\n   */\n  destroy(): void {\n    // Clear all health check timers\n    this.healthCheckTimers.forEach((timer) => {\n      clearInterval(timer);\n    });\n\n    this.healthCheckTimers.clear();\n    this.states.clear();\n  }\n}\n\n/**\n * Factory function for creating circuit breaker\n */\nexport const createCircuitBreaker = (\n  config?: Partial<CircuitBreakerConfig>\n): CircuitBreaker => {\n  return new CircuitBreaker(config);\n};\n"],"version":3}