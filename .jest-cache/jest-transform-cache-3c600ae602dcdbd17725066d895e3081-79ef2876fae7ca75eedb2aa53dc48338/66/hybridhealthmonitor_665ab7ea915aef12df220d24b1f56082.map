{"file":"/Users/matbakh-visibility-boost.20250920/src/lib/ai-orchestrator/hybrid-health-monitor.ts","mappings":";AAAA;;;;;;GAMG;;;AAEH,yDAAoD;AAgHpD;;GAEG;AACH,MAAa,mBAAmB;IACtB,MAAM,CAAqB;IAC3B,YAAY,CAAiB;IAC7B,mBAAmB,CAAsB;IACzC,SAAS,CAAY;IACrB,iBAAiB,CAAoB;IAE7C,0BAA0B;IAClB,YAAY,CAAqB;IACjC,kBAAkB,CAAqB;IACvC,yBAAyB,GAC/B,IAAI,GAAG,EAAE,CAAC;IAEZ,uBAAuB;IACf,mBAAmB,CAAkB;IACrC,gBAAgB,CAAkB;IAClC,cAAc,GAAwB,IAAI,GAAG,EAAE,CAAC;IAExD,wBAAwB;IAChB,eAAe,CAAO;IACtB,eAAe,CAAO;IAE9B,YACE,mBAAwC,EACxC,SAAoB,EACpB,iBAAoC,EACpC,MAAoC;QAEpC,IAAI,CAAC,mBAAmB,GAAG,mBAAmB,CAAC;QAC/C,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,iBAAiB,GAAG,iBAAiB,CAAC;QAC3C,IAAI,CAAC,YAAY,GAAG,IAAI,iCAAc,EAAE,CAAC;QAEzC,IAAI,CAAC,MAAM,GAAG;YACZ,aAAa,EAAE,KAAK,EAAE,aAAa;YACnC,gBAAgB,EAAE,MAAM,EAAE,YAAY;YACtC,iBAAiB,EAAE,OAAO,EAAE,SAAS;YACrC,gBAAgB,EAAE;gBAChB,cAAc,EAAE,EAAE;gBAClB,UAAU,EAAE,IAAI,EAAE,YAAY;gBAC9B,cAAc,EAAE,IAAI;gBACpB,eAAe,EAAE,GAAG,EAAE,MAAM;aAC7B;YACD,0BAA0B,EAAE,IAAI;YAChC,6BAA6B,EAAE,IAAI;YACnC,eAAe,EAAE;gBACf,mBAAmB,EAAE,EAAE;gBACvB,cAAc,EAAE,IAAI,EAAE,YAAY;gBAClC,eAAe,EAAE,KAAK,EAAE,aAAa;aACtC;YACD,GAAG,MAAM;SACV,CAAC;QAEF,IAAI,CAAC,eAAe,GAAG,IAAI,IAAI,EAAE,CAAC;QAClC,IAAI,CAAC,eAAe,GAAG,IAAI,IAAI,EAAE,CAAC;QAClC,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,sBAAsB,EAAE,CAAC;QAClD,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,4BAA4B,EAAE,CAAC;QAE9D,8BAA8B;QAC9B,IAAI,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,iCAAiC,CAAC,EAAE,CAAC;YACnE,IAAI,CAAC,eAAe,EAAE,CAAC;QACzB,CAAC;IACH,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,eAAe;QACnB,IAAI,CAAC;YACH,qCAAqC;YACrC,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,eAAe,EAAE,CAAC;YACzD,MAAM,mBAAmB,GACvB,MAAM,IAAI,CAAC,mBAAmB,CAAC,eAAe,EAAE,CAAC;YAEnD,sBAAsB;YACtB,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,GAAG,GAAG,SAAS,CAAC;YACzC,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,aAAa,GAAG,mBAAmB,CAAC;YAE7D,2BAA2B;YAC3B,IAAI,CAAC,sBAAsB,EAAE,CAAC;YAE9B,4BAA4B;YAC5B,MAAM,IAAI,CAAC,uBAAuB,EAAE,CAAC;YAErC,6BAA6B;YAC7B,IAAI,CAAC,wBAAwB,EAAE,CAAC;YAEhC,2BAA2B;YAC3B,IAAI,CAAC,6BAA6B,EAAE,CAAC;YAErC,yBAAyB;YACzB,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,SAAS,GAAG,IAAI,IAAI,EAAE,CAAC;YACjD,IAAI,CAAC,eAAe,GAAG,IAAI,IAAI,EAAE,CAAC;YAElC,OAAO,EAAE,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;QAClC,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,OAAO,CAAC,KAAK,CAAC,qCAAqC,EAAE,KAAK,CAAC,CAAC;YAE5D,gCAAgC;YAChC,OAAO;gBACL,GAAG,IAAI,CAAC,YAAY;gBACpB,OAAO,EAAE;oBACP,GAAG,IAAI,CAAC,YAAY,CAAC,OAAO;oBAC5B,SAAS,EAAE,KAAK;oBAChB,WAAW,EAAE,CAAC;oBACd,SAAS,EAAE,IAAI,IAAI,EAAE;iBACtB;aACF,CAAC;QACJ,CAAC;IACH,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,wBAAwB;QAC5B,MAAM,UAAU,GAAG,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC7C,MAAM,SAAS,GAAG,IAAI,IAAI,EAAE,CAAC;QAC7B,MAAM,UAAU,GAAG,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC;QAEjD,IAAI,CAAC;YACH,oDAAoD;YACpD,MAAM,eAAe,GAAG,IAAI,CAAC,yBAAyB,CAAC,UAAU,CAAC,CAAC;YACnE,MAAM,cAAc,GAAG,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC,CAAC;YAE1D,6BAA6B;YAC7B,MAAM,eAAe,GAAG,IAAI,CAAC,wBAAwB,CACnD,eAAe,EACf,cAAc,CACf,CAAC;YAEF,+BAA+B;YAC/B,MAAM,qBAAqB,GACzB,IAAI,CAAC,yBAAyB,CAAC,cAAc,CAAC,CAAC;YAEjD,6BAA6B;YAC7B,MAAM,UAAU,GAAG,IAAI,CAAC,0BAA0B,CAChD,eAAe,EACf,qBAAqB,CACtB,CAAC;YAEF,2BAA2B;YAC3B,MAAM,eAAe,GAAG,MAAM,IAAI,CAAC,8BAA8B,CAC/D,eAAe,EACf,qBAAqB,EACrB,UAAU,CACX,CAAC;YAEF,MAAM,QAAQ,GAA8B;gBAC1C,UAAU;gBACV,SAAS;gBACT,UAAU;gBACV,cAAc,EAAE,eAAe,CAAC,MAAM;gBACtC,gBAAgB,EAAE,eAAe,CAAC,MAAM,CACtC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,cAAc,KAAK,CAAC,CAAC,WAAW,CAC1C,CAAC,MAAM;gBACR,mBAAmB,EAAE,eAAe,CAAC,MAAM,CACzC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,cAAc,KAAK,CAAC,CAAC,WAAW,CAC1C,CAAC,MAAM;gBACR,eAAe;gBACf,qBAAqB;gBACrB,eAAe;gBACf,UAAU,EAAE,eAAe,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,EAAE,0BAA0B;aACtF,CAAC;YAEF,iBAAiB;YACjB,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;YAEzD,6CAA6C;YAC7C,IAAI,CAAC,kBAAkB,EAAE,CAAC;YAE1B,OAAO,QAAQ,CAAC;QAClB,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,OAAO,CAAC,KAAK,CAAC,qCAAqC,EAAE,KAAK,CAAC,CAAC;YAE5D,mCAAmC;YACnC,OAAO;gBACL,UAAU;gBACV,SAAS;gBACT,UAAU;gBACV,cAAc,EAAE,CAAC;gBACjB,gBAAgB,EAAE,CAAC;gBACnB,mBAAmB,EAAE,CAAC;gBACtB,eAAe,EAAE;oBACf,QAAQ,EAAE,CAAC;oBACX,kBAAkB,EAAE,CAAC;oBACrB,mBAAmB,EAAE,CAAC;iBACvB;gBACD,qBAAqB,EAAE;oBACrB,cAAc,EAAE,EAAE,cAAc,EAAE,CAAC,EAAE,WAAW,EAAE,CAAC,EAAE,UAAU,EAAE,CAAC,EAAE;oBACpE,wBAAwB,EAAE;wBACxB,cAAc,EAAE,CAAC;wBACjB,WAAW,EAAE,CAAC;wBACd,UAAU,EAAE,CAAC;qBACd;iBACF;gBACD,eAAe,EAAE;oBACf,oBAAoB,EAAE,EAAE;oBACxB,uBAAuB,EAAE,EAAE;oBAC3B,oBAAoB,EAAE,EAAE;iBACzB;gBACD,UAAU,EAAE,CAAC;aACd,CAAC;QACJ,CAAC;IACH,CAAC;IAED;;OAEG;IACH,qBAAqB,CACnB,cAAgC,EAChC,WAA6B,EAC7B,YAAoB,EACpB,MAAc;QAEd,IAAI,CAAC,kBAAkB,CAAC,gBAAgB,CAAC,IAAI,CAAC;YAC5C,SAAS,EAAE,IAAI,IAAI,EAAE;YACrB,cAAc;YACd,WAAW;YACX,YAAY;YACZ,MAAM;SACP,CAAC,CAAC;QAEH,yCAAyC;QACzC,MAAM,UAAU,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC;QAC9D,IAAI,CAAC,kBAAkB,CAAC,gBAAgB;YACtC,IAAI,CAAC,kBAAkB,CAAC,gBAAgB,CAAC,MAAM,CAC7C,CAAC,QAAQ,EAAE,EAAE,CAAC,QAAQ,CAAC,SAAS,CAAC,OAAO,EAAE,GAAG,UAAU,CACxD,CAAC;IACN,CAAC;IAED;;OAEG;IACH,wBAAwB,CACtB,KAAuB,EACvB,OAAe,EACf,OAAgB,EAChB,aAAqB;QAErB,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,IAAI,CAAC;YACpC,SAAS,EAAE,IAAI,IAAI,EAAE;YACrB,KAAK;YACL,OAAO;YACP,OAAO;YACP,aAAa;SACd,CAAC,CAAC;QAEH,wCAAwC;QACxC,MAAM,UAAU,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC;QAC9D,IAAI,CAAC,kBAAkB,CAAC,QAAQ,GAAG,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,MAAM,CACxE,CAAC,OAAO,EAAE,EAAE,CAAC,OAAO,CAAC,SAAS,CAAC,OAAO,EAAE,GAAG,UAAU,CACtD,CAAC;IACJ,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,8BAA8B;QAClC,IAAI,CAAC;YACH,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,wBAAwB,EAAE,CAAC;YAEvD,MAAM,kBAAkB,GAAG;gBACzB,GAAG,QAAQ,CAAC,eAAe,CAAC,oBAAoB;gBAChD,GAAG,QAAQ,CAAC,eAAe,CAAC,uBAAuB;gBACnD,GAAG,QAAQ,CAAC,eAAe,CAAC,oBAAoB;aACjD,CAAC;YAEF,OAAO,kBAAkB,CAAC;QAC5B,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,OAAO,CAAC,KAAK,CAAC,6CAA6C,EAAE,KAAK,CAAC,CAAC;YACpE,OAAO;gBACL,iCAAiC;gBACjC,kCAAkC;gBAClC,+BAA+B;aAChC,CAAC;QACJ,CAAC;IACH,CAAC;IAED;;OAEG;IACH,UAAU;QACR,MAAM,MAAM,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,eAAe,CAAC,OAAO,EAAE,CAAC;QAC3D,MAAM,cAAc,GAAG,IAAI,CAAC,iBAAiB,CAC3C,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAC9B,CAAC;QAEF,OAAO;YACL,MAAM;YACN,aAAa,EAAE,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,MAAM;YACtD,cAAc,EAAE,cAAc,CAAC,MAAM;YACrC,gBAAgB,EAAE,IAAI,CAAC,kBAAkB,CAAC,gBAAgB,CAAC,MAAM;YACjE,kBAAkB,EAAE,IAAI,CAAC,yBAAyB,CAAC,IAAI;YACvD,YAAY,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YAC1C,eAAe,EAAE,IAAI,CAAC,eAAe;YACrC,eAAe,EAAE,IAAI,CAAC,eAAe;SACtC,CAAC;IACJ,CAAC;IAED;;OAEG;IACH,OAAO;QACL,kBAAkB;QAClB,IAAI,IAAI,CAAC,mBAAmB,EAAE,CAAC;YAC7B,aAAa,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC;YACxC,IAAI,CAAC,mBAAmB,GAAG,SAAS,CAAC;QACvC,CAAC;QACD,IAAI,IAAI,CAAC,gBAAgB,EAAE,CAAC;YAC1B,aAAa,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;YACrC,IAAI,CAAC,gBAAgB,GAAG,SAAS,CAAC;QACpC,CAAC;QAED,iBAAiB;QACjB,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;YACtC,YAAY,CAAC,OAAO,CAAC,CAAC;QACxB,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC;QAE5B,aAAa;QACb,IAAI,CAAC,yBAAyB,CAAC,KAAK,EAAE,CAAC;QACvC,IAAI,CAAC,kBAAkB,CAAC,QAAQ,GAAG,EAAE,CAAC;QACtC,IAAI,CAAC,kBAAkB,CAAC,gBAAgB,GAAG,EAAE,CAAC;IAChD,CAAC;IAED,iCAAiC;IAEzB,sBAAsB;QAC5B,OAAO;YACL,OAAO,EAAE;gBACP,SAAS,EAAE,KAAK;gBAChB,WAAW,EAAE,CAAC;gBACd,SAAS,EAAE,IAAI,IAAI,EAAE;gBACrB,MAAM,EAAE,CAAC;aACV;YACD,MAAM,EAAE;gBACN,GAAG,EAAE;oBACH,KAAK,EAAE,KAAK;oBACZ,SAAS,EAAE,KAAK;oBAChB,SAAS,EAAE,CAAC;oBACZ,WAAW,EAAE,CAAC;oBACd,SAAS,EAAE,IAAI,IAAI,EAAE;oBACrB,mBAAmB,EAAE,CAAC;oBACtB,gBAAgB,EAAE,cAAc;oBAChC,SAAS,EAAE,CAAC;oBACZ,iBAAiB,EAAE,CAAC;oBACpB,uBAAuB,EAAE,IAAI;oBAC7B,SAAS,EAAE,CAAC;iBACb;gBACD,aAAa,EAAE;oBACb,SAAS,EAAE,KAAK;oBAChB,SAAS,EAAE,CAAC;oBACZ,SAAS,EAAE,IAAI,IAAI,EAAE;oBACrB,mBAAmB,EAAE,CAAC;oBACtB,mBAAmB,EAAE,QAAQ;iBAC9B;aACF;YACD,OAAO,EAAE;gBACP,UAAU,EAAE,CAAC;gBACb,iBAAiB,EAAE,CAAC;gBACpB,YAAY,EAAE,CAAC;gBACf,mBAAmB,EAAE,CAAC;aACvB;YACD,WAAW,EAAE;gBACX,aAAa,EAAE,CAAC;gBAChB,kBAAkB,EAAE,CAAC;gBACrB,cAAc,EAAE,CAAC;gBACjB,cAAc,EAAE,CAAC;gBACjB,UAAU,EAAE,CAAC;gBACb,UAAU,EAAE,CAAC;aACd;YACD,eAAe,EAAE;gBACf,SAAS,EAAE,EAAE;gBACb,YAAY,EAAE,EAAE;gBAChB,WAAW,EAAE,EAAE;aAChB;SACF,CAAC;IACJ,CAAC;IAEO,4BAA4B;QAClC,OAAO;YACL,QAAQ,EAAE,EAAE;YACZ,gBAAgB,EAAE,EAAE;SACrB,CAAC;IACJ,CAAC;IAEO,eAAe;QACrB,gCAAgC;QAChC,IAAI,IAAI,CAAC,MAAM,CAAC,0BAA0B,EAAE,CAAC;YAC3C,IAAI,CAAC,mBAAmB,GAAG,WAAW,CAAC,KAAK,IAAI,EAAE;gBAChD,IAAI,CAAC;oBACH,MAAM,IAAI,CAAC,eAAe,EAAE,CAAC;gBAC/B,CAAC;gBAAC,OAAO,KAAK,EAAE,CAAC;oBACf,OAAO,CAAC,KAAK,CAAC,+BAA+B,EAAE,KAAK,CAAC,CAAC;gBACxD,CAAC;YACH,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC;QAChC,CAAC;QAED,4BAA4B;QAC5B,IAAI,IAAI,CAAC,MAAM,CAAC,6BAA6B,EAAE,CAAC;YAC9C,IAAI,CAAC,gBAAgB,GAAG,WAAW,CAAC,KAAK,IAAI,EAAE;gBAC7C,IAAI,CAAC;oBACH,MAAM,IAAI,CAAC,wBAAwB,EAAE,CAAC;gBACxC,CAAC;gBAAC,OAAO,KAAK,EAAE,CAAC;oBACf,OAAO,CAAC,KAAK,CAAC,sCAAsC,EAAE,KAAK,CAAC,CAAC;gBAC/D,CAAC;YACH,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,CAAC;QACnC,CAAC;IACH,CAAC;IAEO,sBAAsB;QAC5B,MAAM,SAAS,GAAG,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,GAAG,CAAC;QAC/C,MAAM,mBAAmB,GAAG,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,aAAa,CAAC;QAEnE,kCAAkC;QAClC,IAAI,WAAW,GAAG,CAAC,CAAC;QACpB,IAAI,WAAW,GAAG,CAAC,CAAC;QAEpB,2BAA2B;QAC3B,IAAI,SAAS,CAAC,SAAS,EAAE,CAAC;YACxB,WAAW,IAAI,EAAE,GAAG,CAAC,CAAC,GAAG,SAAS,CAAC,SAAS,CAAC,CAAC;QAChD,CAAC;QACD,WAAW,IAAI,EAAE,CAAC;QAElB,sCAAsC;QACtC,IAAI,mBAAmB,CAAC,SAAS,EAAE,CAAC;YAClC,MAAM,YAAY,GAAG,IAAI,CAAC,GAAG,CAC3B,CAAC,EACD,CAAC;gBACC,mBAAmB,CAAC,SAAS;oBAC3B,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,UAAU,CAC5C,CAAC;YACF,WAAW,IAAI,EAAE,GAAG,YAAY,CAAC;QACnC,CAAC;QACD,WAAW,IAAI,EAAE,CAAC;QAElB,mCAAmC;QACnC,WAAW,IAAI,EAAE,GAAG,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,UAAU,CAAC;QACzD,WAAW,IAAI,EAAE,CAAC;QAElB,kBAAkB;QAClB,MAAM,UAAU,GAAG,WAAW,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,WAAW,GAAG,WAAW,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;QAE3E,wBAAwB;QACxB,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;QAC/D,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,SAAS;YACjC,UAAU,IAAI,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,cAAc,CAAC;QAC5D,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,MAAM;YAC9B,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,eAAe,CAAC,OAAO,EAAE,CAAC;IAChD,CAAC;IAEO,KAAK,CAAC,uBAAuB;QACnC,MAAM,eAAe,GAAG,IAAI,CAAC,yBAAyB,CACpD,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAC9B,CAAC;QAEF,IAAI,eAAe,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACjC,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,UAAU,GAAG,GAAG,CAAC,CAAC,uCAAuC;YACnF,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,iBAAiB,GAAG,GAAG,CAAC;YAClD,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,YAAY,GAAG,CAAC,CAAC;YAC3C,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,mBAAmB,GAAG,CAAC,CAAC;YAClD,OAAO;QACT,CAAC;QAED,+BAA+B;QAC/B,MAAM,gBAAgB,GAAG,eAAe,CAAC,MAAM,CAC7C,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,cAAc,KAAK,CAAC,CAAC,WAAW,CAC1C,CAAC,MAAM,CAAC;QACT,MAAM,iBAAiB,GAAG,eAAe,CAAC,MAAM,CAC9C,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,cAAc,KAAK,CAAC,CAAC,WAAW,CAC1C,CAAC,MAAM,CAAC;QAET,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,UAAU;YAClC,gBAAgB,GAAG,eAAe,CAAC,MAAM,CAAC;QAC5C,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,iBAAiB;YACzC,gBAAgB,GAAG,eAAe,CAAC,MAAM,CAAC;QAC5C,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,YAAY;YACpC,iBAAiB,GAAG,eAAe,CAAC,MAAM,CAAC;QAE7C,MAAM,iBAAiB,GAAG,eAAe,CAAC,MAAM,CAC9C,CAAC,GAAG,EAAE,CAAC,EAAE,EAAE,CAAC,GAAG,GAAG,CAAC,CAAC,YAAY,EAChC,CAAC,CACF,CAAC;QACF,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,mBAAmB;YAC3C,iBAAiB,GAAG,eAAe,CAAC,MAAM,CAAC;IAC/C,CAAC;IAEO,wBAAwB;QAC9B,MAAM,cAAc,GAAG,IAAI,CAAC,iBAAiB,CAC3C,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAC9B,CAAC;QAEF,IAAI,cAAc,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAChC,IAAI,CAAC,YAAY,CAAC,WAAW,GAAG;gBAC9B,aAAa,EAAE,CAAC;gBAChB,kBAAkB,EAAE,CAAC;gBACrB,cAAc,EAAE,CAAC;gBACjB,cAAc,EAAE,CAAC;gBACjB,UAAU,EAAE,CAAC;gBACb,UAAU,EAAE,CAAC;aACd,CAAC;YACF,OAAO;QACT,CAAC;QAED,MAAM,kBAAkB,GAAG,cAAc,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;QACnE,MAAM,cAAc,GAAG,cAAc,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;QAEhE,gCAAgC;QAChC,MAAM,SAAS,GAAG,cAAc;aAC7B,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC;aACrB,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;QACzB,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,MAAM,GAAG,IAAI,CAAC,CAAC;QACrD,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,MAAM,GAAG,IAAI,CAAC,CAAC;QAErD,MAAM,YAAY,GAAG,SAAS,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,OAAO,EAAE,EAAE,CAAC,GAAG,GAAG,OAAO,EAAE,CAAC,CAAC,CAAC;QAE1E,IAAI,CAAC,YAAY,CAAC,WAAW,GAAG;YAC9B,aAAa,EAAE,cAAc,CAAC,MAAM;YACpC,kBAAkB,EAAE,kBAAkB,CAAC,MAAM;YAC7C,cAAc,EAAE,cAAc,CAAC,MAAM;YACrC,cAAc,EAAE,YAAY,GAAG,cAAc,CAAC,MAAM;YACpD,UAAU,EAAE,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC;YACpC,UAAU,EAAE,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC;SACrC,CAAC;IACJ,CAAC;IAEO,6BAA6B;QACnC,MAAM,SAAS,GAAa,EAAE,CAAC;QAC/B,MAAM,YAAY,GAAa,EAAE,CAAC;QAClC,MAAM,WAAW,GAAa,EAAE,CAAC;QAEjC,+BAA+B;QAC/B,IACE,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,WAAW;YACrC,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC,mBAAmB,EAC/C,CAAC;YACD,SAAS,CAAC,IAAI,CACZ,4DAA4D,CAC7D,CAAC;QACJ,CAAC;QAED,IACE,IAAI,CAAC,YAAY,CAAC,WAAW,CAAC,UAAU;YACxC,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC,eAAe,EAC3C,CAAC;YACD,SAAS,CAAC,IAAI,CAAC,sDAAsD,CAAC,CAAC;QACzE,CAAC;QAED,mBAAmB;QACnB,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC;YAC5C,SAAS,CAAC,IAAI,CACZ,6DAA6D,CAC9D,CAAC;QACJ,CAAC;QAED,IAAI,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,GAAG,CAAC,SAAS,GAAG,GAAG,EAAE,CAAC;YACjD,YAAY,CAAC,IAAI,CACf,kEAAkE,CACnE,CAAC;QACJ,CAAC;QAED,8BAA8B;QAC9B,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,aAAa,CAAC,SAAS,EAAE,CAAC;YACtD,SAAS,CAAC,IAAI,CACZ,4DAA4D,CAC7D,CAAC;QACJ,CAAC;QAED,IAAI,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,aAAa,CAAC,mBAAmB,GAAG,CAAC,EAAE,CAAC;YACnE,YAAY,CAAC,IAAI,CACf,iEAAiE,CAClE,CAAC;QACJ,CAAC;QAED,2BAA2B;QAC3B,IAAI,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,UAAU,GAAG,GAAG,EAAE,CAAC;YAC/C,YAAY,CAAC,IAAI,CACf,2DAA2D,CAC5D,CAAC;QACJ,CAAC;QAED,IACE,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,YAAY;YACtC,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,eAAe,EAC5C,CAAC;YACD,YAAY,CAAC,IAAI,CACf,gEAAgE,CACjE,CAAC;QACJ,CAAC;QAED,8BAA8B;QAC9B,IACE,IAAI,CAAC,YAAY,CAAC,WAAW,CAAC,UAAU;YACxC,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC,cAAc,EAC1C,CAAC;YACD,YAAY,CAAC,IAAI,CACf,8DAA8D,CAC/D,CAAC;QACJ,CAAC;QAED,MAAM,WAAW,GACf,IAAI,CAAC,YAAY,CAAC,WAAW,CAAC,aAAa,GAAG,CAAC;YAC7C,CAAC,CAAC,IAAI,CAAC,YAAY,CAAC,WAAW,CAAC,kBAAkB;gBAChD,IAAI,CAAC,YAAY,CAAC,WAAW,CAAC,aAAa;YAC7C,CAAC,CAAC,GAAG,CAAC;QAEV,IAAI,WAAW,GAAG,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,cAAc,EAAE,CAAC;YAC9D,SAAS,CAAC,IAAI,CACZ,8DAA8D,CAC/D,CAAC;QACJ,CAAC;QAED,8BAA8B;QAC9B,WAAW,CAAC,IAAI,CAAC,kDAAkD,CAAC,CAAC;QACrE,WAAW,CAAC,IAAI,CAAC,uDAAuD,CAAC,CAAC;QAC1E,WAAW,CAAC,IAAI,CAAC,oDAAoD,CAAC,CAAC;QAEvE,IAAI,CAAC,YAAY,CAAC,eAAe,GAAG;YAClC,SAAS;YACT,YAAY;YACZ,WAAW;SACZ,CAAC;IACJ,CAAC;IAEO,yBAAyB,CAAC,UAAkB;QAClD,MAAM,UAAU,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,UAAU,CAAC;QAC3C,OAAO,IAAI,CAAC,kBAAkB,CAAC,gBAAgB,CAAC,MAAM,CACpD,CAAC,QAAQ,EAAE,EAAE,CAAC,QAAQ,CAAC,SAAS,CAAC,OAAO,EAAE,GAAG,UAAU,CACxD,CAAC;IACJ,CAAC;IAEO,iBAAiB,CAAC,UAAkB;QAC1C,MAAM,UAAU,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,UAAU,CAAC;QAC3C,OAAO,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,MAAM,CAC5C,CAAC,OAAO,EAAE,EAAE,CAAC,OAAO,CAAC,SAAS,CAAC,OAAO,EAAE,GAAG,UAAU,CACtD,CAAC;IACJ,CAAC;IAEO,wBAAwB,CAC9B,SAAiD,EACjD,QAAwC;QAExC,MAAM,WAAW,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,KAAK,KAAK,KAAK,CAAC,CAAC,MAAM,CAAC;QACrE,MAAM,qBAAqB,GAAG,QAAQ,CAAC,MAAM,CAC3C,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,KAAK,KAAK,QAAQ,CAC5B,CAAC,MAAM,CAAC;QACT,MAAM,aAAa,GAAG,QAAQ,CAAC,MAAM,CAAC;QAEtC,MAAM,mBAAmB,GAAG,SAAS,CAAC,MAAM,CAC1C,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,cAAc,KAAK,CAAC,CAAC,WAAW,CAC1C,CAAC,MAAM,CAAC;QAET,OAAO;YACL,QAAQ,EAAE,aAAa,GAAG,CAAC,CAAC,CAAC,CAAC,WAAW,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC;YAC7D,kBAAkB,EAChB,aAAa,GAAG,CAAC,CAAC,CAAC,CAAC,qBAAqB,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC;YAC/D,mBAAmB;SACpB,CAAC;IACJ,CAAC;IAEO,yBAAyB,CAAC,QAAwC;QACxE,MAAM,WAAW,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,KAAK,KAAK,KAAK,CAAC,CAAC;QAC9D,MAAM,qBAAqB,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,KAAK,KAAK,QAAQ,CAAC,CAAC;QAE3E,MAAM,oBAAoB,GAAG,CAAC,aAA8B,EAAE,EAAE;YAC9D,IAAI,aAAa,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;gBAC/B,OAAO,EAAE,cAAc,EAAE,CAAC,EAAE,WAAW,EAAE,CAAC,EAAE,UAAU,EAAE,CAAC,EAAE,CAAC;YAC9D,CAAC;YAED,MAAM,YAAY,GAAG,aAAa,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,CAAC,EAAE,EAAE,CAAC,GAAG,GAAG,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;YAC1E,MAAM,kBAAkB,GAAG,aAAa,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC;YACzE,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,iBAAiB,GAAG,IAAI,CAAC,CAAC,qBAAqB;YAE5E,OAAO;gBACL,cAAc,EAAE,YAAY,GAAG,aAAa,CAAC,MAAM;gBACnD,WAAW,EAAE,kBAAkB,GAAG,aAAa,CAAC,MAAM;gBACtD,UAAU,EAAE,aAAa,CAAC,MAAM,GAAG,QAAQ,EAAE,sBAAsB;aACpE,CAAC;QACJ,CAAC,CAAC;QAEF,OAAO;YACL,cAAc,EAAE,oBAAoB,CAAC,WAAW,CAAC;YACjD,wBAAwB,EAAE,oBAAoB,CAAC,qBAAqB,CAAC;SACtE,CAAC;IACJ,CAAC;IAEO,0BAA0B,CAChC,SAAiD,EACjD,WAA8D;QAE9D,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC;YAAE,OAAO,GAAG,CAAC;QAEvC,0DAA0D;QAC1D,MAAM,gBAAgB,GAAG,SAAS,CAAC,MAAM,CACvC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,cAAc,KAAK,CAAC,CAAC,WAAW,CAC1C,CAAC,MAAM,CAAC;QACT,MAAM,kBAAkB,GAAG,gBAAgB,GAAG,SAAS,CAAC,MAAM,CAAC;QAE/D,oEAAoE;QACpE,MAAM,OAAO,GAAG,WAAW,CAAC,cAAc,CAAC;QAC3C,MAAM,UAAU,GAAG,WAAW,CAAC,wBAAwB,CAAC;QAExD,IAAI,qBAAqB,GAAG,GAAG,CAAC;QAChC,IAAI,OAAO,CAAC,cAAc,GAAG,CAAC,IAAI,UAAU,CAAC,cAAc,GAAG,CAAC,EAAE,CAAC;YAChE,oDAAoD;YACpD,MAAM,aAAa,GAAG,IAAI,CAAC,GAAG,CAC5B,CAAC,EACD,CAAC,GAAG,OAAO,CAAC,cAAc,GAAG,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,UAAU,CACrE,CAAC;YACF,MAAM,gBAAgB,GAAG,IAAI,CAAC,GAAG,CAC/B,CAAC,EACD,CAAC,GAAG,UAAU,CAAC,cAAc,GAAG,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,UAAU,CACxE,CAAC;YACF,qBAAqB,GAAG,CAAC,aAAa,GAAG,gBAAgB,CAAC,GAAG,CAAC,CAAC;QACjE,CAAC;QAED,8CAA8C;QAC9C,OAAO,kBAAkB,GAAG,GAAG,GAAG,qBAAqB,GAAG,GAAG,CAAC;IAChE,CAAC;IAEO,KAAK,CAAC,8BAA8B,CAC1C,QAA0D,EAC1D,WAA8D,EAC9D,UAAkB;QAElB,MAAM,oBAAoB,GAAa,EAAE,CAAC;QAC1C,MAAM,uBAAuB,GAAa,EAAE,CAAC;QAC7C,MAAM,oBAAoB,GAAa,EAAE,CAAC;QAE1C,uCAAuC;QACvC,IAAI,UAAU,GAAG,GAAG,EAAE,CAAC;YACrB,oBAAoB,CAAC,IAAI,CACvB,yDAAyD,CAC1D,CAAC;QACJ,CAAC;QAED,IAAI,QAAQ,CAAC,mBAAmB,GAAG,QAAQ,CAAC,QAAQ,GAAG,GAAG,EAAE,CAAC;YAC3D,oBAAoB,CAAC,IAAI,CACvB,iEAAiE,CAClE,CAAC;QACJ,CAAC;QAED,IACE,QAAQ,CAAC,QAAQ,GAAG,GAAG;YACvB,WAAW,CAAC,cAAc,CAAC,WAAW,GAAG,GAAG,EAC5C,CAAC;YACD,oBAAoB,CAAC,IAAI,CACvB,+EAA+E,CAChF,CAAC;QACJ,CAAC;QAED,0CAA0C;QAC1C,IACE,WAAW,CAAC,cAAc,CAAC,cAAc;YACzC,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC,cAAc,EAC1C,CAAC;YACD,uBAAuB,CAAC,IAAI,CAC1B,0EAA0E,CAC3E,CAAC;QACJ,CAAC;QAED,IACE,WAAW,CAAC,wBAAwB,CAAC,cAAc;YACnD,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC,cAAc,EAC1C,CAAC;YACD,uBAAuB,CAAC,IAAI,CAC1B,4EAA4E,CAC7E,CAAC;QACJ,CAAC;QAED,IAAI,WAAW,CAAC,cAAc,CAAC,WAAW,GAAG,IAAI,EAAE,CAAC;YAClD,uBAAuB,CAAC,IAAI,CAC1B,4DAA4D,CAC7D,CAAC;QACJ,CAAC;QAED,IAAI,WAAW,CAAC,wBAAwB,CAAC,WAAW,GAAG,IAAI,EAAE,CAAC;YAC5D,uBAAuB,CAAC,IAAI,CAC1B,0EAA0E,CAC3E,CAAC;QACJ,CAAC;QAED,uCAAuC;QACvC,IAAI,QAAQ,CAAC,kBAAkB,GAAG,GAAG,EAAE,CAAC;YACtC,oBAAoB,CAAC,IAAI,CACvB,8DAA8D,CAC/D,CAAC;QACJ,CAAC;QAED,IACE,WAAW,CAAC,cAAc,CAAC,UAAU;YACrC,WAAW,CAAC,wBAAwB,CAAC,UAAU,GAAG,GAAG,EACrD,CAAC;YACD,oBAAoB,CAAC,IAAI,CACvB,kEAAkE,CACnE,CAAC;QACJ,CAAC;QAED,oBAAoB,CAAC,IAAI,CACvB,+DAA+D,CAChE,CAAC;QACF,oBAAoB,CAAC,IAAI,CACvB,mEAAmE,CACpE,CAAC;QAEF,OAAO;YACL,oBAAoB;YACpB,uBAAuB;YACvB,oBAAoB;SACrB,CAAC;IACJ,CAAC;IAEO,kBAAkB;QACxB,MAAM,UAAU,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC,WAAW;QAEhE,KAAK,MAAM,CAAC,EAAE,EAAE,QAAQ,CAAC,IAAI,IAAI,CAAC,yBAAyB,CAAC,OAAO,EAAE,EAAE,CAAC;YACtE,IAAI,QAAQ,CAAC,SAAS,CAAC,OAAO,EAAE,GAAG,UAAU,EAAE,CAAC;gBAC9C,IAAI,CAAC,yBAAyB,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;YAC5C,CAAC;QACH,CAAC;IACH,CAAC;IAEO,kBAAkB;QACxB,OAAO,mBAAmB,IAAI,CAAC,GAAG,EAAE,IAAI,IAAI,CAAC,MAAM,EAAE;aAClD,QAAQ,CAAC,EAAE,CAAC;aACZ,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC;IACxB,CAAC;CACF;AA3zBD,kDA2zBC","names":[],"sources":["/Users/matbakh-visibility-boost.20250920/src/lib/ai-orchestrator/hybrid-health-monitor.ts"],"sourcesContent":["/**\n * Hybrid Health Monitor - Health Monitoring for Both MCP and Direct Bedrock Paths\n *\n * This module implements comprehensive health monitoring for the hybrid routing\n * architecture, tracking both MCP and direct Bedrock paths, analyzing routing\n * efficiency, and providing optimization recommendations.\n */\n\nimport { AiFeatureFlags } from \"./ai-feature-flags\";\nimport {\n  DirectBedrockClient,\n  DirectBedrockHealthCheck,\n} from \"./direct-bedrock-client\";\nimport { IntelligentRouter } from \"./intelligent-router\";\nimport { MCPHealthStatus, MCPRouter } from \"./mcp-router\";\n\n// Hybrid Health Status\nexport interface HybridHealthStatus {\n  overall: {\n    isHealthy: boolean;\n    healthScore: number; // 0-100\n    lastCheck: Date;\n    uptime: number; // milliseconds\n  };\n  routes: {\n    mcp: MCPHealthStatus;\n    directBedrock: DirectBedrockHealthCheck;\n  };\n  routing: {\n    efficiency: number; // 0-1\n    optimalRouteUsage: number; // 0-1\n    fallbackRate: number; // 0-1\n    averageDecisionTime: number; // milliseconds\n  };\n  performance: {\n    totalRequests: number;\n    successfulRequests: number;\n    failedRequests: number;\n    averageLatency: number;\n    p95Latency: number;\n    p99Latency: number;\n  };\n  recommendations: {\n    immediate: string[];\n    optimization: string[];\n    maintenance: string[];\n  };\n}\n\n// Routing Efficiency Analysis\nexport interface RoutingEfficiencyAnalysis {\n  analysisId: string;\n  timestamp: Date;\n  timeWindow: number; // milliseconds\n  totalDecisions: number;\n  optimalDecisions: number;\n  suboptimalDecisions: number;\n  routingPatterns: {\n    mcpUsage: number;\n    directBedrockUsage: number;\n    fallbackOccurrences: number;\n  };\n  performanceComparison: {\n    mcpPerformance: {\n      averageLatency: number;\n      successRate: number;\n      throughput: number;\n    };\n    directBedrockPerformance: {\n      averageLatency: number;\n      successRate: number;\n      throughput: number;\n    };\n  };\n  recommendations: {\n    routingOptimizations: string[];\n    performanceImprovements: string[];\n    configurationChanges: string[];\n  };\n  efficiency: number; // 0-1 overall efficiency score\n}\n\n// Health Check Configuration\nexport interface HybridHealthConfig {\n  checkInterval: number; // How often to perform health checks\n  analysisInterval: number; // How often to analyze routing efficiency\n  performanceWindow: number; // Time window for performance analysis\n  healthThresholds: {\n    minHealthScore: number;\n    maxLatency: number;\n    minSuccessRate: number;\n    maxFallbackRate: number;\n  };\n  enableContinuousMonitoring: boolean;\n  enablePerformanceOptimization: boolean;\n  alertThresholds: {\n    criticalHealthScore: number;\n    warningLatency: number;\n    criticalLatency: number;\n  };\n}\n\n// Performance Metrics\ninterface PerformanceMetrics {\n  requests: Array<{\n    timestamp: Date;\n    route: \"mcp\" | \"direct\";\n    latency: number;\n    success: boolean;\n    operationType: string;\n  }>;\n  routingDecisions: Array<{\n    timestamp: Date;\n    requestedRoute: \"mcp\" | \"direct\";\n    actualRoute: \"mcp\" | \"direct\";\n    decisionTime: number;\n    reason: string;\n  }>;\n}\n\n/**\n * Hybrid Health Monitor for MCP and Direct Bedrock Routing\n */\nexport class HybridHealthMonitor {\n  private config: HybridHealthConfig;\n  private featureFlags: AiFeatureFlags;\n  private directBedrockClient: DirectBedrockClient;\n  private mcpRouter: MCPRouter;\n  private intelligentRouter: IntelligentRouter;\n\n  // Health monitoring state\n  private healthStatus: HybridHealthStatus;\n  private performanceMetrics: PerformanceMetrics;\n  private efficiencyAnalysisHistory: Map<string, RoutingEfficiencyAnalysis> =\n    new Map();\n\n  // Monitoring intervals\n  private healthCheckInterval?: NodeJS.Timeout;\n  private analysisInterval?: NodeJS.Timeout;\n  private activeTimeouts: Set<NodeJS.Timeout> = new Set();\n\n  // System state tracking\n  private systemStartTime: Date;\n  private lastHealthCheck: Date;\n\n  constructor(\n    directBedrockClient: DirectBedrockClient,\n    mcpRouter: MCPRouter,\n    intelligentRouter: IntelligentRouter,\n    config?: Partial<HybridHealthConfig>\n  ) {\n    this.directBedrockClient = directBedrockClient;\n    this.mcpRouter = mcpRouter;\n    this.intelligentRouter = intelligentRouter;\n    this.featureFlags = new AiFeatureFlags();\n\n    this.config = {\n      checkInterval: 30000, // 30 seconds\n      analysisInterval: 300000, // 5 minutes\n      performanceWindow: 3600000, // 1 hour\n      healthThresholds: {\n        minHealthScore: 70,\n        maxLatency: 5000, // 5 seconds\n        minSuccessRate: 0.95,\n        maxFallbackRate: 0.1, // 10%\n      },\n      enableContinuousMonitoring: true,\n      enablePerformanceOptimization: true,\n      alertThresholds: {\n        criticalHealthScore: 50,\n        warningLatency: 3000, // 3 seconds\n        criticalLatency: 10000, // 10 seconds\n      },\n      ...config,\n    };\n\n    this.systemStartTime = new Date();\n    this.lastHealthCheck = new Date();\n    this.healthStatus = this.initializeHealthStatus();\n    this.performanceMetrics = this.initializePerformanceMetrics();\n\n    // Start monitoring if enabled\n    if (this.featureFlags.isEnabled(\"ENABLE_HYBRID_HEALTH_MONITORING\")) {\n      this.startMonitoring();\n    }\n  }\n\n  /**\n   * Get comprehensive hybrid health status\n   */\n  async getHealthStatus(): Promise<HybridHealthStatus> {\n    try {\n      // Get health status from both routes\n      const mcpHealth = await this.mcpRouter.getHealthStatus();\n      const directBedrockHealth =\n        await this.directBedrockClient.getHealthStatus();\n\n      // Update route health\n      this.healthStatus.routes.mcp = mcpHealth;\n      this.healthStatus.routes.directBedrock = directBedrockHealth;\n\n      // Calculate overall health\n      this.calculateOverallHealth();\n\n      // Update routing efficiency\n      await this.updateRoutingEfficiency();\n\n      // Update performance metrics\n      this.updatePerformanceMetrics();\n\n      // Generate recommendations\n      this.generateHealthRecommendations();\n\n      // Update last check time\n      this.healthStatus.overall.lastCheck = new Date();\n      this.lastHealthCheck = new Date();\n\n      return { ...this.healthStatus };\n    } catch (error) {\n      console.error(\"Failed to get hybrid health status:\", error);\n\n      // Return degraded health status\n      return {\n        ...this.healthStatus,\n        overall: {\n          ...this.healthStatus.overall,\n          isHealthy: false,\n          healthScore: 0,\n          lastCheck: new Date(),\n        },\n      };\n    }\n  }\n\n  /**\n   * Perform routing efficiency analysis\n   */\n  async analyzeRoutingEfficiency(): Promise<RoutingEfficiencyAnalysis> {\n    const analysisId = this.generateAnalysisId();\n    const timestamp = new Date();\n    const timeWindow = this.config.performanceWindow;\n\n    try {\n      // Get recent routing decisions and performance data\n      const recentDecisions = this.getRecentRoutingDecisions(timeWindow);\n      const recentRequests = this.getRecentRequests(timeWindow);\n\n      // Calculate routing patterns\n      const routingPatterns = this.calculateRoutingPatterns(\n        recentDecisions,\n        recentRequests\n      );\n\n      // Analyze performance by route\n      const performanceComparison =\n        this.analyzePerformanceByRoute(recentRequests);\n\n      // Calculate efficiency score\n      const efficiency = this.calculateRoutingEfficiency(\n        recentDecisions,\n        performanceComparison\n      );\n\n      // Generate recommendations\n      const recommendations = await this.generateRoutingRecommendations(\n        routingPatterns,\n        performanceComparison,\n        efficiency\n      );\n\n      const analysis: RoutingEfficiencyAnalysis = {\n        analysisId,\n        timestamp,\n        timeWindow,\n        totalDecisions: recentDecisions.length,\n        optimalDecisions: recentDecisions.filter(\n          (d) => d.requestedRoute === d.actualRoute\n        ).length,\n        suboptimalDecisions: recentDecisions.filter(\n          (d) => d.requestedRoute !== d.actualRoute\n        ).length,\n        routingPatterns,\n        performanceComparison,\n        recommendations,\n        efficiency: recentDecisions.length === 0 ? 0 : efficiency, // Return 0 for empty data\n      };\n\n      // Store analysis\n      this.efficiencyAnalysisHistory.set(analysisId, analysis);\n\n      // Clean up old analyses (keep last 24 hours)\n      this.cleanupOldAnalyses();\n\n      return analysis;\n    } catch (error) {\n      console.error(\"Routing efficiency analysis failed:\", error);\n\n      // Return minimal analysis on error\n      return {\n        analysisId,\n        timestamp,\n        timeWindow,\n        totalDecisions: 0,\n        optimalDecisions: 0,\n        suboptimalDecisions: 0,\n        routingPatterns: {\n          mcpUsage: 0,\n          directBedrockUsage: 0,\n          fallbackOccurrences: 0,\n        },\n        performanceComparison: {\n          mcpPerformance: { averageLatency: 0, successRate: 0, throughput: 0 },\n          directBedrockPerformance: {\n            averageLatency: 0,\n            successRate: 0,\n            throughput: 0,\n          },\n        },\n        recommendations: {\n          routingOptimizations: [],\n          performanceImprovements: [],\n          configurationChanges: [],\n        },\n        efficiency: 0,\n      };\n    }\n  }\n\n  /**\n   * Record a routing decision for analysis\n   */\n  recordRoutingDecision(\n    requestedRoute: \"mcp\" | \"direct\",\n    actualRoute: \"mcp\" | \"direct\",\n    decisionTime: number,\n    reason: string\n  ): void {\n    this.performanceMetrics.routingDecisions.push({\n      timestamp: new Date(),\n      requestedRoute,\n      actualRoute,\n      decisionTime,\n      reason,\n    });\n\n    // Keep only recent decisions (last hour)\n    const cutoffTime = Date.now() - this.config.performanceWindow;\n    this.performanceMetrics.routingDecisions =\n      this.performanceMetrics.routingDecisions.filter(\n        (decision) => decision.timestamp.getTime() > cutoffTime\n      );\n  }\n\n  /**\n   * Record a request performance for analysis\n   */\n  recordRequestPerformance(\n    route: \"mcp\" | \"direct\",\n    latency: number,\n    success: boolean,\n    operationType: string\n  ): void {\n    this.performanceMetrics.requests.push({\n      timestamp: new Date(),\n      route,\n      latency,\n      success,\n      operationType,\n    });\n\n    // Keep only recent requests (last hour)\n    const cutoffTime = Date.now() - this.config.performanceWindow;\n    this.performanceMetrics.requests = this.performanceMetrics.requests.filter(\n      (request) => request.timestamp.getTime() > cutoffTime\n    );\n  }\n\n  /**\n   * Get routing optimization recommendations\n   */\n  async getOptimizationRecommendations(): Promise<string[]> {\n    try {\n      const analysis = await this.analyzeRoutingEfficiency();\n\n      const allRecommendations = [\n        ...analysis.recommendations.routingOptimizations,\n        ...analysis.recommendations.performanceImprovements,\n        ...analysis.recommendations.configurationChanges,\n      ];\n\n      return allRecommendations;\n    } catch (error) {\n      console.error(\"Failed to get optimization recommendations:\", error);\n      return [\n        \"Monitor system health regularly\",\n        \"Check routing efficiency metrics\",\n        \"Review performance thresholds\",\n      ];\n    }\n  }\n\n  /**\n   * Get hybrid health metrics\n   */\n  getMetrics() {\n    const uptime = Date.now() - this.systemStartTime.getTime();\n    const recentRequests = this.getRecentRequests(\n      this.config.performanceWindow\n    );\n\n    return {\n      uptime,\n      totalRequests: this.performanceMetrics.requests.length,\n      recentRequests: recentRequests.length,\n      routingDecisions: this.performanceMetrics.routingDecisions.length,\n      efficiencyAnalyses: this.efficiencyAnalysisHistory.size,\n      healthChecks: this.lastHealthCheck ? 1 : 0,\n      systemStartTime: this.systemStartTime,\n      lastHealthCheck: this.lastHealthCheck,\n    };\n  }\n\n  /**\n   * Cleanup resources\n   */\n  destroy(): void {\n    // Clear intervals\n    if (this.healthCheckInterval) {\n      clearInterval(this.healthCheckInterval);\n      this.healthCheckInterval = undefined;\n    }\n    if (this.analysisInterval) {\n      clearInterval(this.analysisInterval);\n      this.analysisInterval = undefined;\n    }\n\n    // Clear timeouts\n    this.activeTimeouts.forEach((timeout) => {\n      clearTimeout(timeout);\n    });\n    this.activeTimeouts.clear();\n\n    // Clear data\n    this.efficiencyAnalysisHistory.clear();\n    this.performanceMetrics.requests = [];\n    this.performanceMetrics.routingDecisions = [];\n  }\n\n  // Private implementation methods\n\n  private initializeHealthStatus(): HybridHealthStatus {\n    return {\n      overall: {\n        isHealthy: false,\n        healthScore: 0,\n        lastCheck: new Date(),\n        uptime: 0,\n      },\n      routes: {\n        mcp: {\n          route: \"mcp\",\n          isHealthy: false,\n          latencyMs: 0,\n          successRate: 0,\n          lastCheck: new Date(),\n          consecutiveFailures: 0,\n          connectionStatus: \"disconnected\",\n          queueSize: 0,\n          pendingOperations: 0,\n          lastSuccessfulOperation: null,\n          errorRate: 0,\n        },\n        directBedrock: {\n          isHealthy: false,\n          latencyMs: 0,\n          lastCheck: new Date(),\n          consecutiveFailures: 0,\n          circuitBreakerState: \"closed\",\n        },\n      },\n      routing: {\n        efficiency: 0,\n        optimalRouteUsage: 0,\n        fallbackRate: 0,\n        averageDecisionTime: 0,\n      },\n      performance: {\n        totalRequests: 0,\n        successfulRequests: 0,\n        failedRequests: 0,\n        averageLatency: 0,\n        p95Latency: 0,\n        p99Latency: 0,\n      },\n      recommendations: {\n        immediate: [],\n        optimization: [],\n        maintenance: [],\n      },\n    };\n  }\n\n  private initializePerformanceMetrics(): PerformanceMetrics {\n    return {\n      requests: [],\n      routingDecisions: [],\n    };\n  }\n\n  private startMonitoring(): void {\n    // Start health check monitoring\n    if (this.config.enableContinuousMonitoring) {\n      this.healthCheckInterval = setInterval(async () => {\n        try {\n          await this.getHealthStatus();\n        } catch (error) {\n          console.error(\"Periodic health check failed:\", error);\n        }\n      }, this.config.checkInterval);\n    }\n\n    // Start efficiency analysis\n    if (this.config.enablePerformanceOptimization) {\n      this.analysisInterval = setInterval(async () => {\n        try {\n          await this.analyzeRoutingEfficiency();\n        } catch (error) {\n          console.error(\"Periodic efficiency analysis failed:\", error);\n        }\n      }, this.config.analysisInterval);\n    }\n  }\n\n  private calculateOverallHealth(): void {\n    const mcpHealth = this.healthStatus.routes.mcp;\n    const directBedrockHealth = this.healthStatus.routes.directBedrock;\n\n    // Calculate weighted health score\n    let healthScore = 0;\n    let totalWeight = 0;\n\n    // MCP health (weight: 0.4)\n    if (mcpHealth.isHealthy) {\n      healthScore += 40 * (1 - mcpHealth.errorRate);\n    }\n    totalWeight += 40;\n\n    // Direct Bedrock health (weight: 0.4)\n    if (directBedrockHealth.isHealthy) {\n      const latencyScore = Math.max(\n        0,\n        1 -\n          directBedrockHealth.latencyMs /\n            this.config.healthThresholds.maxLatency\n      );\n      healthScore += 40 * latencyScore;\n    }\n    totalWeight += 40;\n\n    // Routing efficiency (weight: 0.2)\n    healthScore += 20 * this.healthStatus.routing.efficiency;\n    totalWeight += 20;\n\n    // Normalize score\n    const finalScore = totalWeight > 0 ? (healthScore / totalWeight) * 100 : 0;\n\n    // Update overall health\n    this.healthStatus.overall.healthScore = Math.round(finalScore);\n    this.healthStatus.overall.isHealthy =\n      finalScore >= this.config.healthThresholds.minHealthScore;\n    this.healthStatus.overall.uptime =\n      Date.now() - this.systemStartTime.getTime();\n  }\n\n  private async updateRoutingEfficiency(): Promise<void> {\n    const recentDecisions = this.getRecentRoutingDecisions(\n      this.config.performanceWindow\n    );\n\n    if (recentDecisions.length === 0) {\n      this.healthStatus.routing.efficiency = 1.0; // Perfect efficiency with no decisions\n      this.healthStatus.routing.optimalRouteUsage = 1.0;\n      this.healthStatus.routing.fallbackRate = 0;\n      this.healthStatus.routing.averageDecisionTime = 0;\n      return;\n    }\n\n    // Calculate efficiency metrics\n    const optimalDecisions = recentDecisions.filter(\n      (d) => d.requestedRoute === d.actualRoute\n    ).length;\n    const fallbackDecisions = recentDecisions.filter(\n      (d) => d.requestedRoute !== d.actualRoute\n    ).length;\n\n    this.healthStatus.routing.efficiency =\n      optimalDecisions / recentDecisions.length;\n    this.healthStatus.routing.optimalRouteUsage =\n      optimalDecisions / recentDecisions.length;\n    this.healthStatus.routing.fallbackRate =\n      fallbackDecisions / recentDecisions.length;\n\n    const totalDecisionTime = recentDecisions.reduce(\n      (sum, d) => sum + d.decisionTime,\n      0\n    );\n    this.healthStatus.routing.averageDecisionTime =\n      totalDecisionTime / recentDecisions.length;\n  }\n\n  private updatePerformanceMetrics(): void {\n    const recentRequests = this.getRecentRequests(\n      this.config.performanceWindow\n    );\n\n    if (recentRequests.length === 0) {\n      this.healthStatus.performance = {\n        totalRequests: 0,\n        successfulRequests: 0,\n        failedRequests: 0,\n        averageLatency: 0,\n        p95Latency: 0,\n        p99Latency: 0,\n      };\n      return;\n    }\n\n    const successfulRequests = recentRequests.filter((r) => r.success);\n    const failedRequests = recentRequests.filter((r) => !r.success);\n\n    // Calculate latency percentiles\n    const latencies = recentRequests\n      .map((r) => r.latency)\n      .sort((a, b) => a - b);\n    const p95Index = Math.floor(latencies.length * 0.95);\n    const p99Index = Math.floor(latencies.length * 0.99);\n\n    const totalLatency = latencies.reduce((sum, latency) => sum + latency, 0);\n\n    this.healthStatus.performance = {\n      totalRequests: recentRequests.length,\n      successfulRequests: successfulRequests.length,\n      failedRequests: failedRequests.length,\n      averageLatency: totalLatency / recentRequests.length,\n      p95Latency: latencies[p95Index] || 0,\n      p99Latency: latencies[p99Index] || 0,\n    };\n  }\n\n  private generateHealthRecommendations(): void {\n    const immediate: string[] = [];\n    const optimization: string[] = [];\n    const maintenance: string[] = [];\n\n    // Check critical health issues\n    if (\n      this.healthStatus.overall.healthScore <\n      this.config.alertThresholds.criticalHealthScore\n    ) {\n      immediate.push(\n        \"Critical health issue detected - investigate system status\"\n      );\n    }\n\n    if (\n      this.healthStatus.performance.p95Latency >\n      this.config.alertThresholds.criticalLatency\n    ) {\n      immediate.push(\"Critical latency detected - check system performance\");\n    }\n\n    // Check MCP health\n    if (!this.healthStatus.routes.mcp.isHealthy) {\n      immediate.push(\n        \"MCP route is unhealthy - check connection and configuration\"\n      );\n    }\n\n    if (this.healthStatus.routes.mcp.queueSize > 100) {\n      optimization.push(\n        \"MCP queue size is high - consider increasing processing capacity\"\n      );\n    }\n\n    // Check Direct Bedrock health\n    if (!this.healthStatus.routes.directBedrock.isHealthy) {\n      immediate.push(\n        \"Direct Bedrock route is unhealthy - check AWS connectivity\"\n      );\n    }\n\n    if (this.healthStatus.routes.directBedrock.consecutiveFailures > 5) {\n      optimization.push(\n        \"Direct Bedrock has consecutive failures - review error patterns\"\n      );\n    }\n\n    // Check routing efficiency\n    if (this.healthStatus.routing.efficiency < 0.8) {\n      optimization.push(\n        \"Routing efficiency is low - review routing decision logic\"\n      );\n    }\n\n    if (\n      this.healthStatus.routing.fallbackRate >\n      this.config.healthThresholds.maxFallbackRate\n    ) {\n      optimization.push(\n        \"High fallback rate detected - optimize primary route selection\"\n      );\n    }\n\n    // Performance recommendations\n    if (\n      this.healthStatus.performance.p95Latency >\n      this.config.alertThresholds.warningLatency\n    ) {\n      optimization.push(\n        \"P95 latency is elevated - consider performance optimizations\"\n      );\n    }\n\n    const successRate =\n      this.healthStatus.performance.totalRequests > 0\n        ? this.healthStatus.performance.successfulRequests /\n          this.healthStatus.performance.totalRequests\n        : 1.0;\n\n    if (successRate < this.config.healthThresholds.minSuccessRate) {\n      immediate.push(\n        \"Success rate is below threshold - investigate error patterns\"\n      );\n    }\n\n    // Maintenance recommendations\n    maintenance.push(\"Review health monitoring configuration regularly\");\n    maintenance.push(\"Update routing thresholds based on performance trends\");\n    maintenance.push(\"Clean up old performance data and analysis history\");\n\n    this.healthStatus.recommendations = {\n      immediate,\n      optimization,\n      maintenance,\n    };\n  }\n\n  private getRecentRoutingDecisions(timeWindow: number) {\n    const cutoffTime = Date.now() - timeWindow;\n    return this.performanceMetrics.routingDecisions.filter(\n      (decision) => decision.timestamp.getTime() > cutoffTime\n    );\n  }\n\n  private getRecentRequests(timeWindow: number) {\n    const cutoffTime = Date.now() - timeWindow;\n    return this.performanceMetrics.requests.filter(\n      (request) => request.timestamp.getTime() > cutoffTime\n    );\n  }\n\n  private calculateRoutingPatterns(\n    decisions: PerformanceMetrics[\"routingDecisions\"],\n    requests: PerformanceMetrics[\"requests\"]\n  ) {\n    const mcpRequests = requests.filter((r) => r.route === \"mcp\").length;\n    const directBedrockRequests = requests.filter(\n      (r) => r.route === \"direct\"\n    ).length;\n    const totalRequests = requests.length;\n\n    const fallbackOccurrences = decisions.filter(\n      (d) => d.requestedRoute !== d.actualRoute\n    ).length;\n\n    return {\n      mcpUsage: totalRequests > 0 ? mcpRequests / totalRequests : 0,\n      directBedrockUsage:\n        totalRequests > 0 ? directBedrockRequests / totalRequests : 0,\n      fallbackOccurrences,\n    };\n  }\n\n  private analyzePerformanceByRoute(requests: PerformanceMetrics[\"requests\"]) {\n    const mcpRequests = requests.filter((r) => r.route === \"mcp\");\n    const directBedrockRequests = requests.filter((r) => r.route === \"direct\");\n\n    const calculatePerformance = (routeRequests: typeof requests) => {\n      if (routeRequests.length === 0) {\n        return { averageLatency: 0, successRate: 0, throughput: 0 };\n      }\n\n      const totalLatency = routeRequests.reduce((sum, r) => sum + r.latency, 0);\n      const successfulRequests = routeRequests.filter((r) => r.success).length;\n      const timeSpan = this.config.performanceWindow / 1000; // Convert to seconds\n\n      return {\n        averageLatency: totalLatency / routeRequests.length,\n        successRate: successfulRequests / routeRequests.length,\n        throughput: routeRequests.length / timeSpan, // requests per second\n      };\n    };\n\n    return {\n      mcpPerformance: calculatePerformance(mcpRequests),\n      directBedrockPerformance: calculatePerformance(directBedrockRequests),\n    };\n  }\n\n  private calculateRoutingEfficiency(\n    decisions: PerformanceMetrics[\"routingDecisions\"],\n    performance: ReturnType<typeof this.analyzePerformanceByRoute>\n  ): number {\n    if (decisions.length === 0) return 1.0;\n\n    // Calculate decision efficiency (optimal route selection)\n    const optimalDecisions = decisions.filter(\n      (d) => d.requestedRoute === d.actualRoute\n    ).length;\n    const decisionEfficiency = optimalDecisions / decisions.length;\n\n    // Calculate performance efficiency (actual performance vs expected)\n    const mcpPerf = performance.mcpPerformance;\n    const directPerf = performance.directBedrockPerformance;\n\n    let performanceEfficiency = 1.0;\n    if (mcpPerf.averageLatency > 0 && directPerf.averageLatency > 0) {\n      // Compare actual performance to expected thresholds\n      const mcpEfficiency = Math.max(\n        0,\n        1 - mcpPerf.averageLatency / this.config.healthThresholds.maxLatency\n      );\n      const directEfficiency = Math.max(\n        0,\n        1 - directPerf.averageLatency / this.config.healthThresholds.maxLatency\n      );\n      performanceEfficiency = (mcpEfficiency + directEfficiency) / 2;\n    }\n\n    // Combine decision and performance efficiency\n    return decisionEfficiency * 0.6 + performanceEfficiency * 0.4;\n  }\n\n  private async generateRoutingRecommendations(\n    patterns: ReturnType<typeof this.calculateRoutingPatterns>,\n    performance: ReturnType<typeof this.analyzePerformanceByRoute>,\n    efficiency: number\n  ): Promise<RoutingEfficiencyAnalysis[\"recommendations\"]> {\n    const routingOptimizations: string[] = [];\n    const performanceImprovements: string[] = [];\n    const configurationChanges: string[] = [];\n\n    // Routing optimization recommendations\n    if (efficiency < 0.8) {\n      routingOptimizations.push(\n        \"Review routing decision algorithm for better efficiency\"\n      );\n    }\n\n    if (patterns.fallbackOccurrences > patterns.mcpUsage * 0.1) {\n      routingOptimizations.push(\n        \"High fallback rate - consider adjusting route health thresholds\"\n      );\n    }\n\n    if (\n      patterns.mcpUsage < 0.3 &&\n      performance.mcpPerformance.successRate > 0.9\n    ) {\n      routingOptimizations.push(\n        \"MCP route underutilized despite good performance - review routing preferences\"\n      );\n    }\n\n    // Performance improvement recommendations\n    if (\n      performance.mcpPerformance.averageLatency >\n      this.config.alertThresholds.warningLatency\n    ) {\n      performanceImprovements.push(\n        \"MCP route latency is high - investigate connection and processing delays\"\n      );\n    }\n\n    if (\n      performance.directBedrockPerformance.averageLatency >\n      this.config.alertThresholds.warningLatency\n    ) {\n      performanceImprovements.push(\n        \"Direct Bedrock latency is high - check AWS region and network connectivity\"\n      );\n    }\n\n    if (performance.mcpPerformance.successRate < 0.95) {\n      performanceImprovements.push(\n        \"MCP route success rate is low - investigate error patterns\"\n      );\n    }\n\n    if (performance.directBedrockPerformance.successRate < 0.95) {\n      performanceImprovements.push(\n        \"Direct Bedrock success rate is low - check AWS service limits and errors\"\n      );\n    }\n\n    // Configuration change recommendations\n    if (patterns.directBedrockUsage > 0.7) {\n      configurationChanges.push(\n        \"High Direct Bedrock usage - consider increasing MCP capacity\"\n      );\n    }\n\n    if (\n      performance.mcpPerformance.throughput <\n      performance.directBedrockPerformance.throughput * 0.5\n    ) {\n      configurationChanges.push(\n        \"MCP throughput is significantly lower - review MCP configuration\"\n      );\n    }\n\n    configurationChanges.push(\n      \"Review health check intervals based on current usage patterns\"\n    );\n    configurationChanges.push(\n      \"Consider adjusting routing thresholds based on performance trends\"\n    );\n\n    return {\n      routingOptimizations,\n      performanceImprovements,\n      configurationChanges,\n    };\n  }\n\n  private cleanupOldAnalyses(): void {\n    const cutoffTime = Date.now() - 24 * 60 * 60 * 1000; // 24 hours\n\n    for (const [id, analysis] of this.efficiencyAnalysisHistory.entries()) {\n      if (analysis.timestamp.getTime() < cutoffTime) {\n        this.efficiencyAnalysisHistory.delete(id);\n      }\n    }\n  }\n\n  private generateAnalysisId(): string {\n    return `hybrid-analysis-${Date.now()}-${Math.random()\n      .toString(36)\n      .substring(2, 11)}`;\n  }\n}\n\n// Export types for external use\nexport {\n  type HybridHealthConfig,\n  type HybridHealthStatus,\n  type RoutingEfficiencyAnalysis,\n};\n"],"version":3}