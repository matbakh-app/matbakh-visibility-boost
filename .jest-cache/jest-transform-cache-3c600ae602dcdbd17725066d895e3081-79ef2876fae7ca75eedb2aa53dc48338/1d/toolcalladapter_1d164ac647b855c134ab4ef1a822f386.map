{"file":"/Users/matbakh-visibility-boost.20250920/src/lib/ai-orchestrator/adapters/tool-call-adapter.ts","mappings":"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","names":[],"sources":["/Users/matbakh-visibility-boost.20250920/src/lib/ai-orchestrator/adapters/tool-call-adapter.ts"],"sourcesContent":["import { ProviderResponse, RouteDecision, ToolSpec } from \"../types\";\n\n// OpenAI-like unified tool schema for cross-provider compatibility\nexport interface UnifiedToolSpec {\n  type: \"function\";\n  function: {\n    name: string;\n    description?: string;\n    parameters: {\n      type: \"object\";\n      properties: Record<string, any>;\n      required?: string[];\n      additionalProperties?: boolean;\n    };\n  };\n}\n\n// Enhanced tool call result with provider context\nexport interface UnifiedToolCall {\n  id?: string;\n  type: \"function\";\n  function: {\n    name: string;\n    arguments: string | Record<string, any>;\n  };\n  provider?: string;\n  confidence?: number;\n}\n\nexport interface ToolCallAdapter {\n  // Normalize tool definitions to provider-native format\n  mapTools(tools?: ToolSpec[]): any | undefined;\n\n  // Convert to unified OpenAI-like schema\n  toUnifiedSchema(tools?: ToolSpec[]): UnifiedToolSpec[] | undefined;\n\n  // Convert from unified schema to provider format\n  fromUnifiedSchema(tools?: UnifiedToolSpec[]): any | undefined;\n\n  // Build provider request payload from neutral decision\n  buildRequest(input: {\n    prompt: string;\n    decision: RouteDecision;\n    streaming?: boolean;\n    maxTokens?: number;\n    tools?: ToolSpec[] | UnifiedToolSpec[];\n  }): any;\n\n  // Parse provider response -> neutral shape\n  parseResponse(resp: any): ProviderResponse;\n\n  // Parse tool calls with enhanced error handling\n  parseToolCalls(resp: any): UnifiedToolCall[];\n\n  // Estimate token count for cost calculation\n  estimateTokens(text: string): { input: number; output: number };\n\n  // Get provider-specific configuration\n  getProviderConfig(): {\n    maxContextTokens: number;\n    supportsStreaming: boolean;\n    supportsTools: boolean;\n    supportsJsonMode?: boolean;\n    supportsVision?: boolean;\n    rateLimitRpm: number;\n    fallbackProvider?: string;\n  };\n\n  // Validate tool specification\n  validateToolSpec(tool: ToolSpec | UnifiedToolSpec): boolean;\n\n  // Check if provider supports specific tool features\n  supportsToolFeature(\n    feature: \"parallel_calls\" | \"streaming\" | \"json_schema\" | \"complex_types\"\n  ): boolean;\n}\n\nexport abstract class BaseAdapter implements ToolCallAdapter {\n  abstract mapTools(tools?: ToolSpec[]): any | undefined;\n  abstract buildRequest(input: {\n    prompt: string;\n    decision: RouteDecision;\n    streaming?: boolean;\n    maxTokens?: number;\n    tools?: ToolSpec[] | UnifiedToolSpec[];\n  }): any;\n  abstract parseResponse(resp: any): ProviderResponse;\n  abstract getProviderConfig(): {\n    maxContextTokens: number;\n    supportsStreaming: boolean;\n    supportsTools: boolean;\n    supportsJsonMode?: boolean;\n    supportsVision?: boolean;\n    rateLimitRpm: number;\n    fallbackProvider?: string;\n  };\n\n  // Convert ToolSpec to unified OpenAI-like schema\n  toUnifiedSchema(tools?: ToolSpec[]): UnifiedToolSpec[] | undefined {\n    if (!tools?.length) return undefined;\n\n    return tools.map((tool) => ({\n      type: \"function\" as const,\n      function: {\n        name: tool.name,\n        description: tool.description || `Execute ${tool.name} function`,\n        parameters: {\n          type: \"object\" as const,\n          properties: tool.parameters || {},\n          required: this.extractRequiredFields(tool.parameters),\n          additionalProperties: false,\n        },\n      },\n    }));\n  }\n\n  // Convert unified schema back to provider format (default implementation)\n  fromUnifiedSchema(tools?: UnifiedToolSpec[]): any | undefined {\n    if (!tools?.length) return undefined;\n\n    const toolSpecs: ToolSpec[] = tools.map((tool) => ({\n      name: tool.function.name,\n      description: tool.function.description,\n      parameters: tool.function.parameters.properties,\n    }));\n\n    return this.mapTools(toolSpecs);\n  }\n\n  // Parse tool calls with enhanced error handling\n  parseToolCalls(resp: any): UnifiedToolCall[] {\n    try {\n      const toolCalls = this.extractToolCallsFromResponse(resp);\n      return toolCalls.map((call, index) => ({\n        id: call.id || `call_${index}`,\n        type: \"function\" as const,\n        function: {\n          name: call.name,\n          arguments: this.normalizeArguments(call.arguments),\n        },\n        provider: this.getProviderName(),\n        confidence: call.confidence || 1.0,\n      }));\n    } catch (error) {\n      console.warn(`Failed to parse tool calls: ${error}`);\n      return [];\n    }\n  }\n\n  // Validate tool specification\n  validateToolSpec(tool: ToolSpec | UnifiedToolSpec): boolean {\n    try {\n      if (\"function\" in tool) {\n        // UnifiedToolSpec validation\n        const func = tool.function;\n        return !!(\n          func.name &&\n          func.parameters &&\n          func.parameters.type === \"object\" &&\n          func.parameters.properties\n        );\n      } else {\n        // ToolSpec validation\n        return !!(tool.name && typeof tool.name === \"string\");\n      }\n    } catch {\n      return false;\n    }\n  }\n\n  // Check if provider supports specific tool features (default: basic support)\n  supportsToolFeature(\n    feature: \"parallel_calls\" | \"streaming\" | \"json_schema\" | \"complex_types\"\n  ): boolean {\n    const config = this.getProviderConfig();\n    switch (feature) {\n      case \"parallel_calls\":\n        return config.supportsTools;\n      case \"streaming\":\n        return config.supportsStreaming && config.supportsTools;\n      case \"json_schema\":\n        return config.supportsJsonMode || false;\n      case \"complex_types\":\n        return config.supportsTools;\n      default:\n        return false;\n    }\n  }\n\n  // Simple token estimation (override for provider-specific tokenizers)\n  estimateTokens(text: string): { input: number; output: number } {\n    // Rough estimation: ~4 characters per token for most models\n    const tokens = Math.ceil(text.length / 4);\n    return { input: tokens, output: 0 };\n  }\n\n  // Common error handling with enhanced context\n  protected handleError(error: any, provider: string, context?: string): never {\n    const message = error?.message || \"Unknown error\";\n    const contextStr = context ? ` (${context})` : \"\";\n    throw new Error(`${provider} adapter error${contextStr}: ${message}`);\n  }\n\n  // Common response validation\n  protected validateResponse(resp: any, provider: string): void {\n    if (!resp) {\n      throw new Error(`${provider} returned empty response`);\n    }\n  }\n\n  // Helper methods for subclasses\n  protected extractRequiredFields(parameters?: Record<string, any>): string[] {\n    if (!parameters) return [];\n\n    return Object.entries(parameters)\n      .filter(\n        ([_, schema]) => schema?.required === true || schema?.nullable === false\n      )\n      .map(([key]) => key);\n  }\n\n  protected normalizeArguments(args: any): string | Record<string, any> {\n    if (typeof args === \"string\") {\n      try {\n        return JSON.parse(args);\n      } catch {\n        return args;\n      }\n    }\n    return args || {};\n  }\n\n  // Abstract methods for subclasses to implement\n  protected abstract extractToolCallsFromResponse(resp: any): Array<{\n    id?: string;\n    name: string;\n    arguments: any;\n    confidence?: number;\n  }>;\n\n  protected abstract getProviderName(): string;\n}\n"],"version":3}